DSREF    TITLE '                             D A T A   S E T   U S A G >
               E   B Y   U S E R'
***********************************************************************
*                                                                     *
* Title - DSREF                                                       *
*                                                                     *
* Function / Operation - DSREF uses data from the IBM SMF facility to *
*   produce a report showing the users that access data sets.  A data *
*   set report looks like -                                           *
*                                                                     *
*   dsn   nnn                                                         *
*    user user ... user                                               *
*                                                                     *
*   The list of users report extends over as many lines as are        *
*   required for the data set.  The nnn on the data set line is the   *
*   number of references for the data set, not the number of users    *
*   that referenced the data set.  The user entries in the user       *
*   are in 10 byte cells.  A user with a * before the userid          *
*   indicates the user updated the data set.                          *
*                                                                     *
*   The second report is a list of users followed by the data sets    *
*   the user accessed.  The report looks like this -                  *
*                                                                     *
*   userid                                                            *
*    dsn dsn ... dsn                                                  *
*                                                                     *
*   The dataset list extends over as many lines as are required.      *
*                                                                     *
*   The third report is optional.  It is a list of jobs DSREF         *
*   encountered.  If possible, it displays the userid of the user     *
*   that submitted the job in this report.                            *
*                                                                     *
* JCL -                                                               *
*   //        EXEC PGM=DSREF,PARM=option,option,...'                  *
*   //SYSPRINT DD  -- Data set to receive the report --               *
*   //SMF      DD  -- Data set containing SMF data --                 *
*                                                                     *
*   These options can be specified.                                   *
*    JOBLIST - List the jobs in the input.                            *
*    NOJOBLIST - Do not list the jobs,                                *
*    WIDELINE - Use a 120 byte wide line to list the users for data   *
*     sets.                                                           *
*    NOWIDELINE - Use an 80 byte wide line to list the users for data *
*     sets.                                                           *
*    SORTREFCOUNT - Sort the data set report by the reference count   *
*     for the data set.                                               *
*    SORTDSN - Sort the data set report by data set name.             *
*                                                                     *
*    The default is SORTREFCOUNT,NOWIDELINE,NOJOBLIST                 *
*                                                                     *
* Messages -                                                          *
*    THERE ARE NO VALID RECORDS IN THE SMF DATA SET                   *
*     Reason: DSREF determined there are no valid SMF records in the  *
*      data set specified by the DD statement with DD name SMF.       *
*     Action: DSREF terminates.                                       *
*     Response: Specify a data set containing SMF data and rerun      *
*      DSREF.                                                         *
*    SMF DATA FROM yyyy/mm/dd hh:mm:ss TO yyyy/mm/dd hh:mm:ss         *
*     Reason: Duh                                                     *
*     Action: DSREF produces the report.                              *
*     Response: Review the report.                                    *
*    jjjjjjjj yyyy/mm/dd hh:mm:ss uuuuuuuu                            *
*     Reason: the input data included jobs (or TSO sessions) that     *
*      were submitted at yyyy/mm/dd hh:mm:ss and were run by a user   *
*      with userid uuuuuuuu.  Userid ???????? indicates DSREF was     *
*      unable to determine the userid.  This report appears when      *
*      option JOBLIST is specifieds in the EXEC statement PARM.       *
*     Action: DSREF lists the next job.                               *
*     Response: Review the report.                                    *
*    nnnK BYTES OF STORAAGE ALLOCATED                                 *
*     Reason: DSREF allocated the indicated amount of storage to      *
*      prepare its reports.  Some additional storage for data areas   *
*      for I/O buffers and possible temporary store are also required *
*      and are not included in this value.                            *
*     Action: DSREF terminates.                                       *
*     Response: None required.  This storage is requested             *
*      unconditionally and can result in SB78 ABENDs.                 *
*    OPTIONS: option,...,option                                       *
*     Reason: DSREF lists the option it is using.  The option strings *
*      in the message are the same option strings that can be         *
*      specified in the PARM=ccc parameter in the JCL EXEC statement  *
*      used to run DSREF.                                             *
*     Action: DSREF terminates.                                       *
*     Response: Review the options.  If necessary, correct the        *
*      and rerun DSREF.                                               *
*     Comment: The code in DSREF that analyzes the options ignores    *
*      invalid options without writing an error message.              *
*                                                                     *
* Notes -                                                             *
*   DSREF attempts to reduce "noise" in the output report by not      *
*   reporting access to temporary data sets and to ISPF backup data   *
*   sets.  ISPF backup data sets have data set name                   *
*   userid.ISRnnnn.BACKUP, where nnnn is a 4 digit numeric.           *
*                                                                     *
*   Userid ???? is used by DSREF when it is unable to determine the   *
*   userid of a user accessing a data set.  The only known source     *
*   of a userid in SMF data is the SMF30RUD data srea in the ID       *
*   segment of most SMF type 30 records.  A patient analyst can often *
*   guess a userid by examining the JOBLIST report looking for job    *
*   or TSO sessions with userid ????.  This should be very rare in    *
*   systems that write "interval" SMF type 30 records.                *
*                                                                     *
* Y2K - DSREF is Y2K compliant.                                       *
*                                                                     *
***********************************************************************
         EJECT
DSREF    RSECT
DSREF    AMODE 31
         USING DSREFD,11
         USING *,12
         SAVE  (14,12),,'DSREF &SYSDATE &SYSTIME Copyright (C) 2017 J. >
               Stephen Myers'
         LR    12,15               Prepare
         BAS   14,*+L'*+4           the
         DC    AL4(DSREFD)           base
         L     11,0(,14)              registers
         LA    15,SAVEAREA             and
         ST    13,4(,15)                the
         ST    15,8(,13)                 first
         LR    13,15                      save area
         L     2,0(,1)             Load the address of the PARM text
         BAS   14,INITHDR          Add the run date & time to the     ->
                                    page header
         OPEN  MF=(E,OPARM01)      Open the data sets
         LTR   15,15               All data sets open?
         BNZ   EXIT                No
         BAS   14,PARMSCAN         Scan the PARM text
         USING SMFREC,3
GET0100  GET   SMF                 Retrieve an SMF record
         LR    3,1                 Record woth processing?
         LH    0,0(,3)
         CHI   0,MINSIZE
         BL    GET0100             No
         TP    SMFRDTE             Date packed decimal?
         BNZ   GET0100             No
         ICM   0,B'1111',SMFRTME   Tinme of day valid?
         BM    GET0100
         C     0,=A(100*24*60*60)
         BNL   GET0100
         CLI   SMFRTYP,2           Type 2 record?
         BE    GET0100             Yes
         CLI   SMFRTYP,3           Type 3 record?
         BE    GET0100             Yes
         LA    15,1                Update the
         A     15,RCOUNT            record count
         ST    15,RCOUNT
         CP    SMFRDTE,LOWTIME+4(4)  Lowest date/time for the data set?
         BL    GET0200
         BNE   GET0300
         C     0,LOWTIME
         BNL   GET0300
GET0200  MVC   LOWTIME,SMFRTME     Save lowest date & time
GET0300  CP    SMFRDTE,HIGHTIME+4(4)  Higehest date/time for data set?
         BH    GET0400
         BNE   GET0500
         C     0,HIGHTIME
         BNH   GET0500
GET0400  MVC   HIGHTIME,SMFRTME    Save highest data/time
GET0500  CLI   SMFRTYP,30          Type 30 record?
         BE    GET1300             Yes
         CLI   SMFRTYP,14          Type 14
         BL    GET0100              or
         CLI   SMFRTYP,15            type 15 record?
         BH    GET0100
         LA    1,SMF14JBN          Locate a JOB element
         BAS   14,GETJOB
         LR    10,1                Copy the JOB address to reg 10
         TM    SMF14RIN,SMF14TDS   TEMPORARY DATA SET?
         BO    GET0100             YES
         CLC   =C'SYS',(JFCBDSNM-JFCB)+SMFJFCB1  Test if temporary
         BNE   GET0600                            data set name
         CLI   ((JFCBDSNM-JFCB)+SMFJFCB1)+8,C'.'
         BNE   GET0600
         CLI   ((JFCBDSNM-JFCB)+SMFJFCB1)+16,C'.'
         BNE   GET0600
         TRT   (JFCBDSNM-JFCB)+SMFJFCB1+3(5),TESTNUM
         BNZ   GET0600
         TRT   (JFCBDSNM-JFCB)+SMFJFCB1+10(6),TESTNUM
         BZ    GET0100
GET0600  LA    15,(JFCBDSNM-JFCB)+SMFJFCB1  Test
         LA    0,10                          if
GET0700  CLI   0(15),C'.'                     ISPF
         BE    GET0800                         backup
         LA    15,1(,15)                        data set
         BCT   0,GET0700
         B     GET0900
GET0800  CLC   =C'.ISR',0(15)
         BNE   GET0900
         TRT   4(4,15),TESTNUM
         BNZ   GET0900
         CLC   =C'.BACKUP',8(15)
         BE    GET0100
GET0900  LA    1,(JFCBDSNM-JFCB)+SMFJFCB1  Get a DS
         BAS   14,GETDS
         LR    9,1
         LA    0,1                 Update the
         A     0,DSRCOUNT-DS(,9)    refrence
         ST    0,DSRCOUNT-DS(,9)     count
* Determine if this job has already referenced the data set
         LA    1,(DSREFLST-DS)-(REFNEXT-REF)(,9)
GET1000  ICM   1,B'1111',REFNEXT-REF(1)  LOAD ADDRESS OF THE NEXT     ->
                                            REFERENCE
         BZ    GET1100             THIS DATA SET HAS NOT BEEN         ->
                                    REFERENCED BY THIS JOB
         C     10,REFJOB-REF(,1)    HAS THIS JOB ALREADY REFERENCED   ->
                                     THIS DATA SET?
         BE    GET1200             YES
GET1100  LA    0,REFSIZE           ALLOCATE A NEW REFERENCE
         BAS   14,GETMAIN
         XC    0(REFSIZE,1),0(1)   CLEAR IT
         MVC   REFNEXT-REF(,1),DSREFLST-DS(9)  ADD THE REFERENCE TO
         ST    1,DSREFLST-DS(,9)                THE DATA SET
         ST    10,REFJOB-REF(,1)
GET1200  CLI   SMFRTYP,15          Type 16 record?
         BNE   GET0100             No
         OI    REFFLAG-REF(1),REFOUTPUT  Show output reference
         B     GET0100
         USING SMFRCD30,3
GET1300  ICM   4,B'1111',SMF30IOF  Load offset of the ID area
         BZ    GET0100             No ID area
         AR    4,3                 Compute address of the ID area
         USING SMF30ID,4
* Build a job ID in FMTWORK
         MVC   FMTWORK(L'SMF30JBN),SMF30JBN
         MVC   FMTWORK+L'SMF30JBN(L'SMF30RST),SMF30RST
         MVC   FMTWORK+L'SMF30JBN+L'SMF30RST(L'SMF30RSD),SMF30RSD
         LA    1,FMTWORK           Allocate or find a JOB
         BAS   14,GETJOB
         LR    10,1
         MVC   AJUSER-AJOB(,10),SMF30RUD  Copy the userid to the JOB
         LA    1,SMF30RUD          Get a USER data area
         BAS   14,GETUSER
         B     GET0100
         DROP  3,4
         EJECT
EOF      DC    0H'0'
         ICM   0,B'1111',RCOUNT    Any SMF records?
         BNZ   EOF0100
         LA    1,FMT02
         BAS   14,FMTLINE
         B     EXIT
* Convert the SMF binary time of day to the decimal time of day
* used by MINIFMT
EOF0100  LA    0,LOWTIME
         BAS   14,DECTIME
         LA    0,HIGHTIME
         BAS   14,DECTIME
         LA    1,FMT03             Write the date and time range
         BAS   14,FMTLINE
         LA    0,HDSNO             Build a single linked data set list
         LA    2,HASHDS             from the data set hash table
EOF0200  ICM   1,B'1111',0(2)
         BZ    EOF0300
         MVC   0(4,2),DSNEXT-DS(1)
         MVC   DSNEXT-DS(,1),DSLIST
         ST    1,DSLIST
         B     EOF0200
EOF0300  LA    2,4(,2)
         BCT   0,EOF0200
         LA    2,DSLIST-(DSNEXT-DS)
EOF0400  ICM   2,B'1111',DSNEXT-DS(2)
         BZ    EOF0800
         LA    3,(DSREFLST-DS)-(REFNEXT-REF)(,2)
EOF0500  ICM   3,B'1111',REFNEXT-REF(3)
         BZ    EOF0400
         ICM   4,B'1111',REFJOB-REF(3)
         BZ    EOF0500
         LA    1,AJUSER-AJOB(,4)
         BAS   14,FINDUSER
         LTR   15,15
         BNZ   EOF0500
         LR    4,1
         LA    5,(AUREFLST-AUSER)-(URNEXT-UREF)(,4)
EOF0600  ICM   5,B'1111',URNEXT-UREF(5)
         BZ    EOF0700
         C     2,URDS-UREF(5)
         BNE   EOF0600
         B     EOF0500
EOF0700  LA    0,URSIZE
         BAS   14,GETMAIN
         XC    0(URSIZE,1),0(1)
         MVC   URNEXT-UREF(,1),AUREFLST-AUSER(4)
         ST    1,AUREFLST-AUSER(,4)
         ST    2,URDS-UREF(,1)
         B     EOF0500
EOF0800  L     15,=V(QSORTL)       Sort the data set list
         TM    OPTION,SORTRCNT
         BO    SORTR
         CALL  (15),(,,SORTCMP4),MF=(E,SORTPARM)
         B     RPT0100
SORTR    CALL  (15),MF=(E,SORTPARM)
* Write the data set report
RPT0100  LA    2,DSLIST-(DSNEXT-DS)
         USING DS,2
RPT0200  ICM   2,B'1111',DSNEXT
         BZ    RPT0800
         CLC   DSDSN,=44X'04'      VTOC data set?
         BNE   RPT0300             No
         MVC   DSDSN,=CL44'**VTOC' Change the name for the report
RPT0300  LA    1,FMT04
         BAS   14,FMTLINE
         ICM   0,B'1111',DSREFLST  Any references?
         BZ    RPT0200             No
         XC    LASTUSER,LASTUSER   Reset the last user
         L     15,=V(QSORTL)       Sort the references
         CALL  (15),(DSREFLST,,SORTCMP2),MF=(E,SORTPARM)
         LA    3,DSREFLST-(REFNEXT-REF)
         LA    5,FMTWORK+4+81      Compute the address
         TM    OPTION,WIDELINE      of the
         BZ    RPT0400               end of the line
         LH    5,(DCBLRECL-IHADCB)+PRINT
         LA    5,FMTWORK(5)
RPT0400  LA    14,FMTWORK+5        Compute address of the start of    ->
                                    the line
         MVI   FMTWORK+4,C' '
RPT0500  ICM   3,B'1111',REFNEXT-REF(3)
         BZ    RPT0700
         L     15,REFJOB-REF(,3)
         CLC   AJUSER-AJOB(,15),LASTUSER  Multiple references for     ->
                                           same user?
         BE    RPT0500             Yes
         MVC   LASTUSER,AJUSER-AJOB(15)
         LA    0,10(,14)           Compute end of the user cell
         CR    0,5                 Will cell fit on the line?
         BNH   RPT0600             Yes
         BCTR  14,0                Find the actual end of line
         TM    0(14),255-C' '
         BZ    *-6
         LA    1,FMTWORK           Compute the line length
         SR    14,1
         LA    14,1(,14)
         SLL   14,16               Convert the length to an RDW
         ST    14,FMTWORK
         BAS   14,OUTEDIT          Write the completed line
         LA    14,FMTWORK+5        Start a new line
RPT0600  MVC   0(2,14),=CL2' '     Build a user cell
         MVC   2(8,14),LASTUSER
         TM    REFFLAG-REF(3),REFOUTPUT  Output?
         BZ    *+L'*+4             No
         MVI   1(14),C'*'          Flag cell as output
         LA    14,10(,14)          Compute address of the next cell
         B     RPT0500
* All references identified, print the last line
RPT0700  BCTR  14,0
         TM    0(14),255-C' '
         BZ    RPT0700
         LA    1,FMTWORK
         SR    14,1
         LA    14,1(,14)
         CHI   14,5
         BNL   *+L'*+4
         LA    14,5
         SLL   14,16
         ST    14,FMTWORK
         BAS   14,OUTEDIT
         B     RPT0200
         DROP  2
RPT0800  NOPR  0
* Build a single user list from the hash table
         LA    0,HUSERNO           Load number of entries
         LA    2,HASHUSER          Load address of the hash table
RPT0900  ICM   1,B'1111',0(2)      Load address of an AUSER
         BZ    RPT1000             No more left
         MVC   0(4,2),AUNEXT-AUSER(1)  Remove the AUSER from the table
         MVC   AUNEXT-AUSER(,1),USERLIST  Add the AUSER to
         ST    1,USERLIST                  the user list
         B     RPT0900             Do it again
RPT1000  LA    2,4(,2)             Compute address of the next entry
         BCT   0,RPT0900           Do it again
         L     15,=V(QSORTL)       Sort the user list
         CALL  (15),(USERLIST,,SORTCMP5),MF=(E,SORTPARM)
         MVI   CC,C'-'
         LA    2,USERLIST-(AUNEXT-AUSER)
RPT1100  ICM   2,B'1111',AUNEXT-AUSER(2)  Load addr of the next AUSER
         BZ    RPT2800             Done
         ICM   0,B'1111',AUREFLST-AUSER(2)  Any references?
         BZ    RPT1100                      No
         LA    1,FMT07             Print the userid
         BAS   14,FMTLINE
         MVI   CC,C' '
         L     15,=V(QSORTL)
         CALL  (15),(AUREFLST-AUSER(,2),,SORTCMP6),MF=(E,SORTPARM)
         LA    6,FMTWORK+4+81          Prepare the address of the
         TM    OPTION,WIDELINE          end of the line
         BZ    RPT1200
         LH    6,(DCBLRECL-IHADCB)+PRINT
         LA    6,FMTWORK(6)
RPT1200  LA    5,FMTWORK+5         Load address of the first data     ->
                                    set cell
         LA    3,(AUREFLST-AUSER)-(URNEXT-UREF)(,2)
RPT1300  ICM   3,B'1111',URNEXT-UREF(3) Load address of the next ref
         BZ    RPT1700             End of references
         L     4,URDS-UREF(,3)     Load address of the DS
RPT1400  LA    15,DSDSN+L'DSDSN-DS(,4)  Compute bytes in the name
         BCTR  15,0
         TM    0(15),255-C' '
         BZ    *-6
         LA    0,DSDSN-DS(,4)
         SR    15,0
         BNM   *+L'*+2
         DC    H'0'                Length <= 0!?
         LA    0,2(15,5)           Compute address of the end of the  ->
                                    data set cell
         CR    0,6                 Will data set fit on the line?
         BNH   RPT1600             Yes, add data set to the line
         LA    1,FMTWORK           Print the line
         LR    0,5
         SR    0,1
         SLL   0,16
         ST    0,FMTWORK
         BAS   14,OUTEDIT
         LA    5,FMTWORK+5         Start the next line
         B     RPT1400
RPT1500  MVC   1(*-*,5),DSDSN-DS(4) ** EX only **
RPT1600  MVI   0(5),C' '           Insert the separatot
         EX    15,RPT1500          Copy the data set
         LA    5,2(15,5)           Compute address of the next cell
         B     RPT1300
RPT1700  LA    1,FMTWORK           Print the last line for the ds
         LR    0,5
         SR    0,1
         SLL   0,16
         ST    0,FMTWORK
         BAS   14,OUTEDIT
         B     RPT1100
RPT2800  TM    OPTION,JLIST        JOBLIST?
         BZ    RPT3200             No
* Build a single job list from the job hash table
         LA    0,HJOBNO
         LA    2,HASHJOB
RPT2900  ICM   1,B'1111',0(2)
         BZ    RPT3000
         MVC   0(4,2),AJNEXT-AJOB(1)
         MVC   AJNEXT-AJOB(,1),JOBLIST
         ST    1,JOBLIST
         B     RPT2900
RPT3000  LA    2,4(,2)
         BCT   0,RPT2900
* Sort the job list
         L     15,=V(QSORTL)
         CALL  (15),(JOBLIST,,SORTCMP3),MF=(E,SORTPARM)
* Print the JOBLIST report
         LA    2,JOBLIST-(AJNEXT-AJOB)
         MVI   CC,C'-'
RPT3100  ICM   2,B'1111',AJNEXT-AJOB(2)
         BZ    RPT3200
         LA    0,AJRTIME-AJOB(,2)
         BAS   14,DECTIME
         LA    1,FMT05
         BAS   14,FMTLINE
         MVI   CC,C' '
         B     RPT3100
RPT3200  TM    OPTION,ULIST
         BZ    RPT4000
*        L     15,=V(QSORTL)
*        CALL  (15),(USERLIST,,SORTCMP5),MF=(E,SORTPARM)
         ICM   0,B'1111',USERLIST
         BZ    RPT4000
         LA    3,FMTWORK+4
         LA    4,FMTWORK+4+81
         LA    2,USERLIST-(AUNEXT-AUSER)
         MVI   CC,C'-'
RPT3500  ICM   2,B'1111',AUNEXT-AUSER(2)
         BZ    RPT3900
RPT3600  LA    15,AUUSER-AUSER+L'AUUSER(,2)
         BCTR  15,0
         TM    0(15),255-C' '
         BZ    *-6
         LA    0,AUUSER-AUSER(,2)
         SR    15,0
         BNM   *+L'*+2
         DC    H'0'
         LA    0,2(15,3)
         CR    0,4
         BNH   RPT3800
         LA    1,FMTWORK
         LR    0,3
         SR    0,1
         SLL   0,16
         ST    0,FMTWORK
         MVC   FMTWORK+4(1),CC
         MVI   CC,C' '
         BAS   14,OUTEDIT
         LA    3,FMTWORK+4
         B     RPT3600
RPT3700  MVC   1(*-*,3),AUUSER-AUSER(2)
RPT3800  NOPR  0
         CHI   15,7
         BNH   *+L'*+2
         DC    H'0'
         MVI   0(3),C' '
         EX    15,RPT3700
         LA    3,2(15,3)
         B     RPT3500
RPT3900  LA    1,FMTWORK
         LR    0,3
         SR    0,1
         SLL   0,16
         ST    0,FMTWORK
         MVC   FMTWORK+4(1),CC
         MVI   CC,C' '
         BAS   14,OUTEDIT
* Compute storage allocated by the GETMAIN function
RPT4000  SR    2,2
         LA    1,CPLIST-(CPNEXT-CPOOL)
RPT4100  ICM   1,B'1111',CPNEXT-CPOOL(1)
         BZ    RPT4200
         A     2,CPSIZE-CPOOL(1)
         B     RPT4100
RPT4200  SRL   2,10                Comvert storage to K units
         LA    1,FMT06
         BAS   14,FMTLINE
* PREPARE THE OPTIONS IN EFFECT LIST
*                               ----+----
         MVC   FMTWORK+4(10),=C'-OPTIONS:'
         LA    3,FMTWORK+4+9       Compute start of options text
         LA    4,PSTAB             Load address of the option table
RPT4300  CLI   0(4),X'FF'          End of option table?
         BE    RPT4600             Yes
         SR    15,15
         IC    15,0(,4)            Load length og option string
         MVC   12(1,13),OPTION     Copy options to a work area
         NC    12(1,13),3(4)       Isolate option bitT
         CLC   12(1,13),4(4)       Option in effect?
         BNE   RPT4400             No
         MVI   0(3),C','           Add a ,
         EX    15,RPT4500          Copy option text to message
         LA    3,2(15,3)           Advance output pointer
RPT4400  LA    4,6(15,4)           Compute address of next option
         B     RPT4300             Do it again
RPT4500  MVC   1(*-*,3),5(4)       ** EX only **
RPT4600  MVI   FMTWORK+4+9,C' '    Replace ,
         LA    1,FMTWORK           Load address of the message
         SR    3,1                 Compute message length
         SLL   3,16                Convert length to an RDW
         ST    3,0(,1)             Store the RDW in the message
         BAS   14,OUTEDIT          Write the message
EXIT     LA    1,CPARM01           Close the data sets
         BAS   14,CLOSELST
         BAS   14,FREEALL          Free storage allocated by GETMAIN
         L     13,4(,13)           Exit
         RETURN (14,12),RC=0
         EJECT
         CNOP  0,8
PARMSCAN BASR  15,0
         SAVE  (14,12),,PARMSCAN   Save registers
         LH    5,0(,2)             Load the length of the parm text
         LTR   5,5                 Any text?
         BZ    PS0900              No, exit
         LA    3,2(,2)             Compute address of the first byte
         LA    4,1
         LA    5,1(5,2)            Compute address of last text byte
PS0100   LR    6,3                 Save address of start of string
PS0200   CLI   0(3),C','           End of string?
         BE    PS0300              Yes
         BXLE  3,4,PS0200          Advance the pointer
PS0300   LR    7,3                 Copy end of string addr to reg 7
         SR    7,6                 Compute length of string
         BNP   PS0800              Skip if <= 0
         BCTR  7,0                 Reduce the length
         LA    1,PSTAB             Compute address of the option table
PS0400   CLI   0(1),X'FF'          End of table?
         BE    PS0800              Yes
         CLM   7,B'0001',0(1)      Option string length = keyword len?
         BNE   PS0700              No
         EX    7,PS0500            String match option?
         BNE   PS0700              No
         NC    OPTION,2(1)         Turn off bits
         OC    OPTION,1(1)         Turn on bits
         B     PS0700
PS0500   CLC   0(*-*,6),5(1)       ** EX ONLY **
PS0700   SR    15,15               Reg 15 = 0
         IC    15,0(,1)            Load string length
         LA    1,6(15,1)           COMPUTE ADDR OF NEXT TABLE ENTRY
         B     PS0400
PS0800   BXLE  3,4,PS0100          Advance string pointer
PS0900   RETURN (14,12)            Restore registers & return
         EJECT
* CONVERT BINARY TIME OF DAY TO DECIMAL TIME OF DAY
         CNOP  0,8
DECTIME  BASR  15,0
         SAVE  (14,2),,DECTIME
         LA    15,72(,13)
         ST    13,4(,15)
         ST    15,8(,13)
         LR    13,15
         LR    2,0
         L     0,0(,2)
         L     15,=V(CNVTBIN)
         CALL  (15)
         ST    0,0(,2)
         L     13,4(,13)
         RETURN (14,2)
         EJECT
         CNOP  0,8
GETDS    BASR  15,0
         SAVE  (14,3),,GETDS
         LA    15,72(,13)
         ST    13,4(,15)
         ST    15,8(,13)
         LR    13,15
         L     15,=CL4' '
         LR    3,1
         L     1,0(,1)
         C     15,4(3)
         BE    GETD0100
         AL    1,4(,3)
         C     15,8(,3)
         BE    GETD0100
         AL    1,8(,3)
         C     15,12(,3)
         BE    GETD0100
         AL    1,12(,3)
         C     15,16(,3)
         BE    GETD0100
         AL    1,16(,3)
         C     15,20(,3)
         BE    GETD0100
         AL    1,20(,3)
         C     15,24(,3)
         BE    GETD0100
         AL    1,24(,3)
         C     15,28(,3)
         BE    GETD0100
         AL    1,28(,3)
         C     15,32(,3)
         BE    GETD0100
         AL    1,32(,3)
         C     15,36(,3)
         BE    GETD0100
         AL    1,36(,3)
         C     15,40(,3)
         BE    GETD0100
         AL    1,40(,3)
GETD0100 SR    0,0
         D     0,=A(HDSNO)
         LR    2,0
         SLL   2,2
         LA    2,HASHDS(2)
         LR    1,2
GETD0200 ICM   1,B'1111',0(1)
         BZ    GETD0300
         CLC   DSDSN-DS(,1),0(3)
         BNE   GETD0200
         B     GETD0400
GETD0300 LA    0,DSSIZE
         BAS   14,GETMAIN
         XC    0(DSSIZE,1),0(1)
         MVC   DSDSN-DS(,1),0(3)
         MVC   DSNEXT-DS(,1),0(2)
         ST    1,0(,2)
GETD0400 L     13,4(,13)
         ST    1,24(,13)
         RETURN (14,3)
         EJECT
         CNOP  0,8
GETJOB   BASR  15,0
         SAVE  (14,3),,GETJOB
         LA    15,72(,13)
         ST    13,4(,15)
         ST    15,8(,13)
         LR    13,15
         LR    3,1
         SR    0,0
         PACK  64(5,13),0(9,3)
         L     1,64(,13)
         AL    1,8(,3)
         AL    1,12(,3)
         SR    0,0
         D     0,=A(HJOBNO)
         LR    2,0
         SLL   2,2
         LA    2,HASHJOB(2)
         LR    1,2
GETJ0100 ICM   1,B'1111',0(1)
         BZ    GETJ0200
         CLC   AJKEY-AJOB(,1),0(3)
         BNE   GETJ0100
         B     GETJ0300
GETJ0200 LA    0,AJSIZE
         BAS   14,GETMAIN
         XC    0(AJSIZE,1),0(1)
         MVC   AJKEY-AJOB(,1),0(3)
         MVC   AJUSER-AJOB(,1),=8C'?'
         MVC   AJNEXT-AJOB(,1),0(2)
         ST    1,0(,2)
GETJ0300 L     13,4(,13)
         ST    1,24(,13)
         RETURN (14,3)
         EJECT
         CNOP  0,8
GETUSER  BASR  15,0
         SAVE  (14,3),,GETUSER     Save registers
         LA    15,72(,13)          Prepare a
         ST    13,4(,15)            new
         ST    15,8(,13)             save
         LR    13,15                  area
         LR    3,1                 Copy the key address to reg 3
         SR    0,0                 Set reg 0 = 0
         PACK  64(5,13),0(9,3)     Compact the key
         L     1,64(,13)           Load the compacted key
         D     0,=A(HUSERNO)       Divide the key by the number of    ->
                                    words in the hash table
         LR    2,0                 Copy the remainder to reg 2
         SLL   2,2                 Multiply the remainder by 4
         LA    2,HASHUSER(2)       Compute the address of the hash    ->
                                    alias entry in USERHASH
         LR    1,2                 Copy the address to reg 1
GETU0100 ICM   1,B'1111',0(1)      Load the address of the next AUSER
         BZ    GETU0200            Br if no AUSERs match the key
         CLC   AUUSER-AUSER(,1),0(3)  Does this AUSER MATCH?
         BNE   GETU0100            No, go try thenext AUSER
         B     GETU0300            Got it, exit
GETU0200 LA    0,AUSIZE            Allocate storage for the new AUSER
         BAS   14,GETMAIN
         XC    0(AUSIZE,1),0(1)      Initialize the
         MVC   AUUSER-AUSER(,1),0(3)  new AUSER
         MVC   AUNEXT-AUSER(,1),0(2) Add the new AUSER to
         ST    1,0(,2)                 USERHASH
GETU0300 L     13,4(,13)           Load address of the higher save area
         ST    1,24(,13)           Replace the caller's reg 1 with    ->
                                    address of the AUSER
         RETURN (14,3)             Restore registers & return
         EJECT
         CNOP  0,8
FINDUSER BASR  15,0
         SAVE  (14,0),,FINDUSER    Save registers
         SR    14,14               Set reg 14 = 0
         PACK  64(5,13),0(9,1)     Compact the userid
         L     15,64(,13)          Load the compacted userid
         D     14,=A(HUSERNO)      Divide userid by hash table size
         SLL   14,2                Multiply the remainder by 4
         LA    14,HASHUSER(14)     Compute the address of the hash    ->
                                    table entry for the userid
FU0100   ICM   14,B'1111',AUNEXT-AUSER(14)  Load addr of the next AUSER
         BZ    FU0200              Nothing
         CLC   AUUSER-AUSER(,14),0(1)  Correct AUSER?
         BNE   FU0100              No, try the next AUSER
         LR    1,14                Copy the AUSER address to reg 1
         RETURN (14,0),RC=0        Restore registers & return
FU0200   RETURN (14,0),RC=4        Not found, restore regs & return
         EJECT
* Insert run date & time into the page header
         CNOP  0,8
INITHDR  BASR  15,0                Store current address in reg 15
         SAVE  (14,0),,INITHDR     Save registers
         LA    15,72(,13)          Compute addr of the next save area
         ST    13,4(,15)           Add new save area to the
         ST    15,8(,13)            save area chain
         LR    13,15               Establish new save area pointer
         LA    0,FMTWORK           Load addr of the MINIFMT work area
         LA    1,FMT01             Load addr of the format
         L     15,=V(MINIFMT)      Load addr of the format program
         CALL  (15)                Format the system date & time
         LA    0,4(,1)             Compute addr of the date & time text
         LH    15,0(,1)            Load length of the message
         AHI   15,-4               Compute length of the next
         LA    14,PAGEHDR+97       Compute addr of date & time in hdr
         LR    1,15                Copy length to reg 1
         MVCL  14,0                Copy date & time to the page hdr
         L     13,4(,13)           Load addr of the higher save area
         RETURN (14,0),T           Restore registers & return
         EJECT
* Test if a DD statement is allocated
         CNOP  0,8
TESTDD   BASR  15,0                Store current addr in reg 16
         SAVE  (14,3),,TESTDD      Save registers
         LR    2,1                 Copy OPEN parm list addr to reg 2
         SR    3,3                 Set the return code
TDD0100  L     1,0(,2)             Load a DCB address
         N     1,=A(X'FFFFFF')     Isolate the 24-bit DCB address
         DEVTYPE DCBDDNAM-IHADCB(,1),64(,13)  Test if DD present
         LTR   15,15               Test DEVTYPE return code
         JZ    TDD0200             Br if RC = 0
         LHI   3,4                 Reset my return code
TDD0200  TM    0(2),X'80'          Test if end of the OPEN parm list
         LA    2,4(,2)             Compute addr of the next DCB pointer
         JZ    TDD0100             Br if not end of the OPEN parm list
         LR    15,3                Copy my return code to reg 15
         RETURN (14,3),T,RC=(15)   Restore regs & return
         EJECT
* Open one or more DCBs
         CNOP  0,8
OPENLIST BASR  15,0                Store current address in reg 15
         SAVE  (14,2),,OPENLIST    Save registers
         LR    2,1                 Copy parm list addr to reg 2
         OPEN  MF=(E,(2))          Open the DCBs
         SR    15,15               Set preliminary return code
OL0100   L     1,0(,2)             Load a DCB address
         N     1,=A(X'FFFFFF')     Isolate the 24-bit DCB address
         TM    DCBOFLGS-IHADCB(1),DCBOFOPN  Test if the DCB is open
         JO    *+8                 Br if so
         LHI   15,4                Reset the return code
         TM    0(2),X'80'          Test if end of the parm list
         LA    2,4(,2)             Compute addr of the next DCB pointer
         JZ    OL0100              Br if not end of the parm list
         RETURN (14,2),T,RC=(15)   Restore regs & return
         EJECT
* Close one or more DCBs and free their buffer pools
         CNOP  0,8
CLOSELST BASR  15,0                Store current address in reg 15
         SAVE  (14,2),,CLOSELST    Save registers
         LR    2,1                 Copy parm list address to reg 2
         CLOSE MF=(E,(1))          Close the DCBs
CL0100   L     1,0(,2)             Load a DCB addr from the parm list
         N     1,=A(X'FFFFFF')     Isolate the 24-bit DCB address
         TM    DCBOFLGS-IHADCB(1),DCBOFOPN  Test if the DCB is open
         JO    CL0200              Br if so
         TM    (DCBBUFCB-IHADCB)+3(1),1  Test if there is a buffer pool
         JO    CL0200              Br if not
         FREEPOOL (1)              Free the buffer pool
CL0200   TM    0(2),X'80'          Test if end of the parm list
         LA    2,4(,2)             Compute addr of the next DCB pointer
         JZ    CL0100              Br if not end of the parm list
         RETURN (14,2),T           Restore registers & return
         EJECT
* Prepare an output line using MINIFMT and then "print" the line
         CNOP  0,8
FMTLINE  BASR  15,0                Store current address in reg 15
         SAVE  14,,FMTLINE         Save reg 14
         LA    15,72(,13)          Compute addr of the next save area
         ST    15,8(,13)           Add new save area to the
         ST    13,4(,15)            save area chain
         LR    13,15               Establish new save area pointer
         LA    0,FMTWORK           Load addr of the MINIFMT work area
         L     15,=V(MINIFMT)      Load addr of MINIFMT
         CALL  (15)                Format the line
*        BRAS  14,OUTEDIT          Write the formatted line
         L     13,4(,13)           Load addr of the higher save area
         L     14,12(,13)          Reload reg 15
         J     OUTEDIT             Go write the completed line
*        L     13,4(,13)           Load addr of the higher save area
*        RETURN 14,T               Restore reg 14 & return
         EJECT
* "Print" a line, after inserting a page header if required.
         CNOP  0,8
OUTEDIT  BASR  15,0                Store current address in reg 15
         SAVE  (14,4),,OUTEDIT     Save registers
         LR    2,1                 Copy line address to reg 2
         SR    3,3                 Set reg 3 = 0
         SR    4,4                 Set reg 4 = 0
         LA    15,72(,13)          Compute addr of the next save area
         ST    15,8(,13)           Add new save area to the
         ST    13,4(,15)            save area chain
         LR    13,15               Establish new save area pointer
*        LH    0,0(,2)             Load the line length
*        CH    0,(DCBLRECL-IHADCB)+PRINT  Test the length
*        JNH   *+L'*+6             Br if length <= lrecl
*        MVC   0(2,2),(DCBLRECL-IHADCB)+PRINT  Reset the length
         IC    3,4(,1)             Load the carriage control character
         IC    4,OELINES(3)        Load lines this line will print
         AH    4,LINECT            Add current page position
         CHI   4,60                Compare new page position with     ->
                                    max lines on a page
         JNH   OE0100              Br if new line will fit on the     ->
                                    current page
         AP    PAGENUM,=P'1'       Add 1 to the page number
         MVC   PAGE#,=X'402020202120'  Convert page number to digits
         ED    PAGE#,PAGENUM
         PUT   PRINT,PAGEHDR       Write the page header
         MVI   4(2),C'0'           Replace the carriage control
         LHI   4,3                 Set new page position
OE0100   PUT   PRINT,(2)           Write the line
         STH   4,LINECT            Update the page position
         STC   3,4(,2)             Restore original carriage control
         L     13,4(,13)           Load addr of the higher save area
         RETURN (14,4),T           Restore registers & return
         EJECT
* Allocate a small amount of storage
         DC    0D'0'
CPAMT    EQU   4*1024              BYTES IN A SINGLE CELL POOL
GETMAIN  BASR  15,0                STORE CURRENT ADDRESS IN REG 15
*        USING *,12                ESTABLISH ADDRESSABILITY
         USING CPOOL,10
         SAVE  (14,12),,GETMAIN    SAVE REGISTERS
*        LR    12,15               COPY ENTRY POINT ADDRESS TO REG 12
         LR    2,0                 COPY AMOUNT OF STORAGE TO REG 2
         AHI   2,7                 ROUND REQUEST UP TO AN 8 BYTE
         N     2,ROUND8             MULTIPLE
GM0100   LA    10,CPLIST-(CPNEXT-CPOOL)  LOAD ADDR OF A DUMMY CPOOL
GM0200   ICM   10,B'1111',CPNEXT   LOAD ADDR OF THE NEXT CPOOL
         JZ    GM0300              BR IF END OF LIST
         C     2,CPLEFT            COMPARE REQUESTED AMOUNT WITH      ->
                                    FREE STORAGE IN THIS CPOOL
         JH    GM0200              BR IF NOT ENOUGH STORAGE IN THIS   ->
                                    CPOOL
         MVC   24(4,13),CPNEXTA    REPLACE CALLER'S REG 1 W/ CURRENT  ->
                                    FREE SPACE ADDRESS IN THIS CPOOL
         L     0,CPLEFT            LOAD FREE BYTES IN THIS CPOOL
         SR    0,2                 SUBTRACT AMOUNT OF STORAGE WE      ->
                                    JUST ALLOCATED
         ST    0,CPLEFT            UPDATE FREE SPACE AMOUNT
         A     2,CPNEXTA           ADD ADDRESS OF STORAGE WE JUST     ->
                                    ALLOCATED TO AMOUNT OF STORAGE    ->
                                     WE JUST ALLOCATED
         ST    2,CPNEXTA           UPDATE ADDRESS OF FREE STORAGE
         J     GM0800              AND EXIT
GM0300   LHI   0,CPAMT-(CPSTART-CPOOL)  SET REG 0 = FREE STORAGE IN A ->
                                         SINGLE CPOOL
GM0400   CR    0,2                 COMPARE W/ AMOUNT WE NEED
         JNL   GM0500              BR IF ENOUGH
         AHI   0,CPAMT             ADD CPAMT TO REG 0
         J     GM0400              CONTINUE
GM0500   AHI   0,CPSTART-CPOOL     SET REG 0 TO A K MULTIPLE
         LR    3,0                 COPY AMOUNT OF STORAGE TO REG 3
         TAM   ,                   TEST ADDRESSING MODE
         JNZ   GM0600              BR IF NOT AMODE 24
         GETMAIN RU,LV=(0)         ALLOCATE STORAGE
         J     GM0700
GM0600   GETMAIN RU,LV=(0),LOC=(31,ANY)  ALLOCATE STORAGE
GM0700   LR    10,1                COPY ADDRESS TO REG 11
*        XC    0(CPSTART-CPOOL,11),0(11)  CLEAR THE HEADER
         ST    3,CPSIZE            STORE THE SIZE
         LA    0,CPSTART
         ST    0,CPNEXTA
         AHI   3,-(CPSTART-CPOOL)  SUBTRACT HEADER SIZE FROM          ->
                                    ALLOCATED STORAGE
         ST    3,CPLEFT            STORE FREE SPACE SIZE
         MVC   CPNEXT,CPLIST       ADD THE NEW SUBPOOL TO THE
         ST    10,CPLIST            SUBPOOL CHAIN
         J     GM0100              AND RESTART ALLOCATION
GM0800   RETURN (14,12),T          RESTORE REGS & RETURN
         SPACE 5
         CNOP  0,8
FREEALL  BASR  15,0                STORE CURRENT ADDRESS IN REG 15
*        USING *,12                ESTABLISH ADDRESSABILITY
         SAVE  (14,12),,FREEALL    SAVE REGISTERS
*        LR    12,15               COPY THE ENTRY POINT ADDR TO REG 12
FR0100   ICM   10,B'1111',CPLIST   LOAD ADDR OF THE NEXT CPOOL
         JZ    FR0200              EXIT IF DONE
         MVC   CPLIST,CPNEXT       REMOVE CURRENT CPOOL FROM THE CHAIN
         L     0,CPSIZE            LOAD SIZE
         FREEMAIN RU,LV=(0),A=(10) FREE THE CPOOL
         J     FR0100              GO FREE THE NEXT CPOOL
FR0200   RETURN (14,12),T          RESTORE REGS & RETURN
         SPACE 1
ROUND8   DC    F'-8'
         DROP  10
         SPACE 5
         CNOP  0,8
*        PUSH  USING
*        DROP  ,
L        USING DS,14
R        USING DS,1
SORTCMP1 SAVE  14
         LM    14,15,0(1)
         L     14,0(,14)
         L     1,0(,15)
         LA    15,1
         L     0,R.DSRCOUNT
         C     0,L.DSRCOUNT
         JL    SC0200
         JH    SC0300
         CLC   L.DSDSN,R.DSDSN
         JL    SC0200
         JH    SC0300
         J     SC0100
         SPACE 5
L        USING REF,14
R        USING REF,1
SORTCMP2 SAVE  14
         LM    14,15,0(1)
         L     14,0(,14)
         L     1,0(,15)
         LA    15,1
         CLC   R.REFFLAG,L.REFFLAG
         JL    SC0200
         JH    SC0300
         L     14,L.REFJOB
         L     1,R.REFJOB
L        USING AJOB,14
R        USING AJOB,1
         CLC   L.AJUSER,R.AJUSER
         JL    SC0200
         JH    SC0300
         J     SC0100
         SPACE 3
         CNOP  0,8
L        USING AJOB,14
R        USING AJOB,1
SORTCMP3 SAVE  14
         LM    14,15,0(1)
         L     14,0(,14)
         L     1,0(,15)
         LA    15,1
*        CP    L.AJRDATE,R.AJRDATE
*        JL    SC0200
*        JH    SC0300
*        L     0,L.AJRTIME
*        C     0,R.AJRTIME
*        JL    SC0200
*        JH    SC0300
         CLC   L.AJOBNAME,R.AJOBNAME
         JL    SC0200
         JH    SC0300
         CP    L.AJRDATE,R.AJRDATE
         JL    SC0200
         JH    SC0300
         L     0,L.AJRTIME
         C     0,R.AJRTIME
         JL    SC0200
         JH    SC0300
         J     SC0100
         SPACE 5
         CNOP  0,8
L        USING DS,14
R        USING DS,1
SORTCMP4 SAVE  14
         LM    14,15,0(1)
         L     14,0(,14)
         L     1,0(,15)
         LA    15,1
         CLC   L.DSDSN,R.DSDSN
         JL    SC0200
         JH    SC0300
         J     SC0100
         SPACE 5
L        USING AUSER,14
R        USING AUSER,1
         CNOP  0,8
SORTCMP5 SAVE  14
         LM    14,15,0(1)
         L     14,0(,14)
         L     1,0(,15)
         LA    15,1
         CLC   L.AUUSER,R.AUUSER
         JL    SC0200
         JH    SC0300
         J     SC0100
         SPACE 5
         CNOP  0,8
L        USING UREF,14
R        USING UREF,1
SORTCMP6 SAVE  14
         LM    14,15,0(1)
         L     14,0(,14)
         L     1,0(,15)
         LA    15,1
         L     14,L.URDS
         L     1,R.URDS
L        USING DS,14
R        USING DS,1
         CLC   L.DSDSN,R.DSDSN
         JL    SC0200
         JH    SC0300
*        J     SC0100
SC0100   SR    15,15
         J     SC0300
SC0200   LNR   15,15
SC0300   RETURN 14,RC=(15)
         DROP  L,R
         DC    0D'0'
         EJECT
DSREFD   CSECT
OELINES  DC    0XL256'0'
* These statements depend on the EBCDIC collating sequence
         DC    (C' ')X'FF',AL1(1) Blank < + < - < 0              1 OF 5
         DC    (C'+'-(*-OELINES))X'FF',AL1(0)                    2 OF 5
         DC    (C'-'-(*-OELINES))X'FF',AL1(3)                    3 OF 5
         DC    (C'0'-(*-OELINES))X'FF',AL1(2)                    4 OF 5
         DC    (256-(*-OELINES))X'FF'                            5 OF 5
TESTNUM  DC    0XL256'0',(C'0')X'04',10X'00',(256-(*-TESTNUM))X'04'
SAVEAREA DC    (5*9)D'0'           5 72 byte OS/360 save areas
FMTWORK  DC    XL200'0'            MINIFMT work area
LASTUSER DC    CL8' '
LOWTIME  DC    0XL8'0',X'7FFFFFFF',PL4'999365'
HIGHTIME DC    0XL8'0',F'0',PL4'1'
RCOUNT   DC    F'0'
DSLIST   DC    A(*-*)
JOBLIST  DC    A(*-*)
USERLIST  DC   A(*-*)
SORTPARM CALL  ,(DSLIST,SORTOFF,SORTCMP1),MF=L
SORTOFF  DC    A(*-*)
CPLIST   DC    A(*-*)              ADDRESS OF FIRST SUBPOOL
LINECT   DC    H'255',0F'0'        Initial page position
         PUSH  PRINT
         PRINT NOGEN
OPARM01  OPEN  (PRINT,OUTPUT,SMF,INPUT),MF=L
CPARM01  CLOSE (PRINT,,SMF),MF=L
PRINT    DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=VBA,LRECL=125
SMF      DCB   DSORG=PS,MACRF=GL,DDNAME=SMF,BFTEK=A,EODAD=EOF
         POP   PRINT
         DC    0D'0'
         LTORG ,
PSTAB    DC    AL1(6,JLIST,X'FF',JLIST,JLIST),C'JOBLIST'
         DC    AL1(8,0,255-JLIST,JLIST,0),C'NOJOBLIST'
         DC    AL1(7,WIDELINE,X'FF',WIDELINE,WIDELINE),C'WIDELINE'
         DC    AL1(9,0,255-WIDELINE,WIDELINE,0),C'NOWIDELINE'
*                                       ----+----1--
         DC    AL1(11,SORTRCNT,X'FF',SORTRCNT,SORTRCNT),C'SORTREFCOUNT'
*                                      ----+--
         DC    AL1(6,0,255-SORTRCNT,SORTRCNT,0),C'SORTDSN'
*        DC    AL1(7,ULIST,X'FF',ULIST,ULIST),C'USERLIST'  OPTIONS
*        DC    AL1(9,0,255-ULIST,ULIST,0),C'NOUSERLIST'     DELETED
         DC    X'FF'
OPTION   DC    AL1(SORTRCNT)
JLIST    EQU   X'80'
WIDELINE EQU   X'40'
SORTRCNT EQU   X'20'
ULIST    EQU   X'08'
LEFT     EQU   ((120-L'HDR)/2)+1
RIGHT    EQU   111-LEFT-L'HDR
PAGEHDR  DC    AL2(PAGEHDRL,0),CL(LEFT)'1(DSREF &SYSDATE &SYSTIME)'
HDR      DC    C'D A T A   S E T   U S A G E    B Y   U S E R'
         DC    CL(RIGHT)' '
         DC    C'PAGE'
PAGE#    DC    C' NNNNN'
PAGEHDRL EQU   *-PAGEHDR
PAGENUM  DC    P'00000'
         SPACE 1
C0       EQU   X'C0'
FMT01    DC    AL.2(2),AL.6(4),AL1(1,1),X'FF' Format system date & time
         SPACE 1
FMT02    DC    AL1(L'FMT02A)
FMT02A   DC    C' THERE ARE NO VALID RECORDS IN THE SMF DATA SET',X'FF'
         SPACE 1
FMT03    DC    AL1(L'FMT03A)
FMT03A   DC    C' SMF DATA FROM '
         DC    AL1(C0+5,1,3),SL2(LOWTIME)
         DC    AL1(4),CL4' TO '
         DC    AL1(C0+5,1,3),SL2(HIGHTIME),X'FF'
         SPACE 1
         USING DS,2
FMT04    DC    AL1(1),C' '
         DC    AL1(C0+0,L'DSDSN,L'DSDSN),SL2(DSDSN)
         DC    AL1(C0+1,L'DSRCOUNT,6),SL2(DSRCOUNT),X'FF'
         DROP  2
         SPACE 1
         USING AJOB,2
FMT05    DC    AL1(X'80'+0,L'CC,L'CC),AL4(CC)
         DC    AL1(C0+0,L'AJOBNAME,L'AJOBNAME+1),SL2(AJOBNAME)
         DC    AL1(C0+5,1,3),SL2(AJRTIME)
         DC    AL1(1),C' '
         DC    AL1(C0+0,L'AJUSER,0),SL2(AJUSER),X'FF'
         DROP  2
         SPACE 1
FMT06    DC    AL1(1),C'-'
         DC    AL1(C0+10,4,0),SL2(28(13))
         DC    AL1(L'FMT06B)
FMT06B   DC    C'K BYTES OF STORAGE ALLOCATED',X'FF'
         SPACE 1
         USING AUSER,2
FMT07    DC    AL1(X'80'+0,L'CC,L'CC),AL4(CC)
         DC    AL1(C0+0,L'AUUSER,0),SL2(AUUSER),X'FF'
         DROP  2
         SPACE 1
CC       DC    C' '
         SPACE 1
HASHJOB  DC    31A(*-*)
HJOBNO   EQU   (*-HASHJOB)/L'HASHJOB
         SPACE 1
HASHUSER DC    31A(*-*)
HUSERNO  EQU   (*-HASHUSER)/L'HASHUSER
         SPACE 1
HASHDS   DC    31A(*-*)
HDSNO    EQU   (*-HASHDS)/L'HASHDS
         SPACE 1
         DC    0D'0'
DSREF    RSECT
         SPACE 2
         PUSH  PRINT
         PRINT NOGEN
         DCBD  DSORG=QS,DEVD=DA
         SPACE 2
CPOOL    DSECT                     CELL POOL CONTAINER
CPNEXT   DS    A                   ADDRESS OF THE NEXT CONTAINER
CPSIZE   DS    F                   BYTES ALLOCATED FOR THIS SUBPOOL
CPLEFT   DS    F                   FREE BYTES LEFT IN THIS CONTAINER
CPNEXTA  DS    A,0D                ADDRESS OF FIRST FREE BYTE
CPSTART  EQU   *
         SPACE 2
SMFREC   DSECT
SMFRDW   DS    2AL2,AL1
SMFRTYP  DS    AL1
SMFRTME  DS    FL4
SMFRDTE  DS    PL4
MINSIZE  EQU   *-SMFREC
         ORG   SMFREC
         IFASMFR 14
         ORG   SMFREC
         IFASMFR 30
         EJECT
DS       DSECT
DSNEXT   DS    A
DSDSN    DS    CL44
DSREFLST DS    A
DSRCOUNT DS    F
         DS    0D
DSSIZE   EQU   *-DS
         SPACE 2
REF      DSECT
REFNEXT  DS    A
REFTIME  DS    F
REFDATE  DS    PL4
REFJOB   DS    A
REFFLAG  DS    AL1
REFOUTPUT EQU  X'80'
         DS    0D
REFSIZE  EQU   *-REF
         SPACE 2
AJOB     DSECT
AJNEXT   DS    A
AJOBNAME DS    CL8
AJRTIME  DS    F
AJRDATE  DS    PL4
AJKEY    EQU   AJOBNAME,*-AJOBNAME
AJUSER   DS    CL8
         DS    0D
AJSIZE   EQU   *-AJOB
         SPACE 2
AUSER    DSECT
AUNEXT   DS    A
AUUSER   DS    CL8
AUREFLST DS    A
         DS    0D
AUSIZE   EQU   *-AUSER
         SPACE 2
UREF     DSECT
URNEXT   DS    A
URDS     DS    A
         DS    0D
URSIZE   EQU   *-UREF
         SPACE 2
JFCB     DSECT
         IEFJFCBN ,
         POP   PRINT
         END   DSREF
