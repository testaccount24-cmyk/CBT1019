SCAN118  TITLE '                             T S O   U S E R   I P   A >
               D D R E S S E S'
***********************************************************************
*                                                                     *
* Title -- SCAN118                                                    *
*                                                                     *
* Function / Operation -- SCAN118 analyzes SMF record types 118 and   *
*   30.  Type 118 records contain data about TCPIP sessions that are  *
*   bridged to VTAM.  Type 30 records contain job or TSO session      *
*   status.  SCAN118 attempts to connect TSO sessions to their        *
*   corresponding VTAM / TCPIP session to report the TCPIP IP address *
*   of the user.  SCAN118 produces three reports:                     *
*    - TSO sessions                                                   *
*    - TCPIP - VTAM bridge sessions, sorted by the date and time the  *
*      session started.                                               *
*    - TCPIP session count by IP address.                             *
*                                                                     *
* JCL --                                                              *
*   //        EXEC PGM=SCAN118,PARM='option,option,...'               *
*   //SYSPRINT DD  -- Output report data set --                       *
*   //SMF      DD  -- Sequential SMF data --                          *
*                                                                     *
*   Options -                                                         *
*    - SORTUSER - Sort user list by userid.                           *
*    - SORTTIME - Sort user list by logon time.  This is the default. *
*    - SORTIP - Sort user list by IP address                          *
*    - DUMPRECS - Dump SMF type 118 records as they enter SCAN118.    *
*    - NODUMPRECS - Reset DUMPRECS switch.  This is the default.      *
*    - SESSION - List the TCPIP sessions.                             *
*    - NOSESSION - Do not list the TCPIP sessions.                    *
*                                                                     *
* Status / Change Level --                                            *
*   V1L5 -- October 2016                                              *
*    - Addressability changes.                                        *
*    - The message in FMT14 altered to be more correct.               *
*    - Add options SESSION / NOSESSION to determine if the VTAM       *
*      session report is produced.  The default is SESSION.           *
*    - List the options.                                              *
*   V1L4 -- September 2016                                            *
*    - Add report showing IP addresses with 2 or more users.          *
*   V1L3 -- May 2016                                                  *
*    - Improve addressability.                                        *
*    - Display SMF data range as a subheader on all pages.            *
*    - Use the active MAN data set if SMF DD statement not in JCL.    *
*      Limit processing to the previous 24 hours.                     *
*   V1L2 -- April 2016                                                *
*    - Improve performance of TSO session to IP address lookup.       *
*    - Improve TSO session to IP address reliability.                 *
*    - Validate SMF30RSD and SMF30RST in SMF 30 records, dump bad     *
*      records.                                                       *
*    - Add option SORTIP to sort user list by IP address.             *
*    - Drop LU to IP address report sorted by IP address.  The effect *
*      of this report has been replaced by the IP address count       *
*      report.                                                        *
*    - Add new options DUMPRECS and NODUMPRECS to specify whether     *
*      SMF type 118 records are dumped as they enter the program.     *
*   V1L1 -- March 2016                                                *
*    - Use record subtype to eliminate non Telnet records.  The       *
*      contents of SMFHDSUB do not appear to be documented; the       *
*      actual value (20, Telnet LOGN records, 21 Telnet LOGF records) *
*      are used in the program.                                       *
*    - In TSO to VTAM LU session match, remove requirement that TSO   *
*      LOGOFF time is <= LU logoff time.                              *
*    - Correct generation of the decimal offset value in DUMPREC.     *
*    - Correct creation of multiple SESSIONs for TSO sessions that    *
*      slop over to multiple Type 30 subtype 5 records.               *
*    - Add PARMSCAN routine with options.                             *
*      - SORTUSER (Sort user list by userid).                         *
*      - SORTTIME (Sort user list  by logon time) (default).          *
*      - Add code to implement the options.                           *
*   V1L0 -- March 2016                                                *
*                                                                     *
* Attributes -- SCAN118 is not reenterable, not refreshable and not   *
*   reusable.  It operates in task mode, enabled, problem key and     *
*   problem state.  It uses no z/OS APF restricted resources.         *
*                                                                     *
* External functions -                                                *
*   MINIFMT - Prepare a V format record using a format                *
*   CNVTBIN (an entry point in MINIFMT) - Convert SMF binary time of  *
*      day to unsigned packed decimal for MINIFMT                     *
*   SMFETIME - Calculate elapsed time between 2 SMF date/time areas   *
*   QSORTL - "Sort" a linked list, and rechain the list in            *
*      sort order                                                     *
*                                                                     *
* Return codes -                                                      *
*    0 - Normal completion                                            *
*    4 - Invalid SMF type 118 or type 30 record encountered, bad      *
*        record is dumped.                                            *
*   12 - No valid SMF records in input                                *
*   16 - Unable to open the data sets.  See IEC130I messages in the   *
*        job log.                                                     *
*                                                                     *
***********************************************************************
         SPACE 5
* Compare two SMF style date/time areas
*
         MACRO
&NAME    CMPDT &F1,&F2,&LOW,&HIGH
&NAME    CP    &F1+4(4),&F2+4(4)   Compare the dates
         JL    &LOW                Branch if first date < second date
         JH    &HIGH               Branch if first date > second date
         L     0,&F1               Load first time of day
         C     0,&F2               Compare time of days
         JL    &LOW                Branch if first TOD < second TOD
         JH    &HIGH               Branch if first TOD > second TOD
         MEND
         SPACE 2
* Update return code
*
         MACRO
&NAME    SETCC &ADDR,&RC
         LCLC  &R
         AIF   ('&RC'(1,1) EQ '(').RFORM
&NAME    CLI   &ADDR,&RC           Compare existing code with         ->
                                    proposed code
         JH    *+L'*+4             Br if existing code > proposed code
         MVI   &ADDR,&RC           Store new code
         MEXIT
.RFORM   ANOP
&R       SETC  '&RC(1)'
&NAME    CLM   &R,B'0001',&ADDR    Compare proposed code with         ->
                                    existing code
         JNH   *+L'*+4             Br if proposed code <= existing code
         STC   &R,&ADDR            Replace existing code with new code
         MEND
         SPACE 2
         MACRO
&NAME    VBCLC  &TEXT,&REC,&OFFSET
         LCLB  &QUIT
         LCLC  &P,&R
&P       SETC  '$&SYSNDX'
         AIF   ('&TEXT'(1,1) EQ '''').TESTOFF
         MNOTE 8,'*** THE FIRST PARAMETER MUST SPECIFY A TEXT STRING EN>
               CLOSED IN SINGLE QUOTES ***'
&QUIT    SETB  (1)
.TESTOFF AIF   ('&OFFSET' NE '').TESTREC
         MNOTE 8,'*** THE THIRD POSITIONAL PARAMETER FOR THE RECORD OFF>
               SET MUST BE SPECIFIED ***'
&QUIT    SETB  (1)
.TESTREC AIF   ('&REC'(1,1) EQ '(').XPAND
         MNOTE 8,'*** &REC MUST BE  SPECIFIED AS A REGISTER, EG SOMETHI>
               NG LIKE (5) ***'
&QUIT    SETB  (1)
.XPAND   AIF   (&QUIT).X
&R       SETC  '&REC(1)'
&P.A     DC    0C&TEXT
&NAME    LH    15,0(,&R)           LOAD THE RECORD LENGTH
         CHI   15,L'&P.A+&OFFSET   COMPARE THE ACTUAL RECORD LENGTH    >
                                    WITH THE LENGTH OF THE COMPARE AREA
         JL    *+L'*+6             BR IF WE CAN'T DO THE COMPARE
         CLC   =C&TEXT,&OFFSET.(&R.)  PERFORM THE COMPARE
.X       MEND
         SPACE 5
SCAN118  RSECT
         PUSH  PRINT
         PRINT NOGEN
         CVT   DSECT=YES
         SPACE 2
         IEESMCA ,
         SPACE 2
         DCBD  DSORG=QS,DEVD=DA
         SPACE 2
         IFGACB
         IFGRPL
         SPACE 2
         IEFZB4D0
         IEFZB4D2
         SPACE 2
RDS      DSECT                     SMF RECORDING DATA SET
RDSRDS   DS    CL4'RDS'            EYECATCHER
RDSNEXT  DS    A                   -> NEXT RDS
RDSPREV  DS    A                   -> PREVIOUS RDS
RDSFLAG  DS    AL1                 FLAGS --
RDSAVAIL EQU   X'04'                 SMF DATA SET IS AVAILABLE
         DS    2AL1
RDSDSNL  DS    AL1                 LENGTH OF DATA SET NAME
RDSDSN   DS    CL44                DATA SET NAME
RDSVOL   DS    CL6                 VOLUME
         DS    2AL1
RDSDDN   DS    CL8                 DDNAME
RDSSIZE  DS    F                   NUMBER OF BLOCKS IN DATA SET
RDSUSED  DS    F                   USED BLOCKS IN DATA SET
         SPACE 2
CPOOL    DSECT                     CELL POOL CONTAINER
CPNEXT   DS    A                   ADDRESS OF THE NEXT CONTAINER
CPSIZE   DS    F                   BYTES ALLOCATED FOR THIS SUBPOOL
CPLEFT   DS    F                   FREE BYTES LEFT IN THIS CONTAINER
CPNEXTA  DS    A,0D                ADDRESS OF FIRST FREE BYTE
CPSTART  EQU   *
         SPACE 2
IP       DSECT
IPNEXT   DS    A
IPV4ADDR DS    F
IPULIST  DS    A
         DS    0D
IPSIZE   EQU   *-IP
         SPACE 2
LU       DSECT                     VTAM / TCPIP bridge session
LUNEXT   DS    A                   -> Next LU
LUACTP   DS    A                   -> LUACT
LUNAME   DS    CL8                 VTAM LU name
         DS    0D
LUSIZE   EQU   *-LU
         SPACE 2
LUACT    DSECT                     Active IP session
LUANEXT  DS    A                   -> Next LUACT
LUALU    DS    A                   -> LU using the IP
LUAIP    DS    F                   IP V4 address
LUAONDT  DS    XL8                 SMF date/time session started
LUAOFFDT DS    XL8                 SMF date/time session ended
         DS    0D
LUASIZE  EQU   *-LUACT
         SPACE 2
LUC      DSECT                     IP address usde counter
LUCNEXT  DS    A                   -> Next LUC
LUCIP    DS    F                   IP V4 address
LUCCOUNT DS    F                   Counter
         DS    0D
LUCSIZE  EQU   *-LUC
         SPACE 2
SESSION  DSECT                     TSO session
SENEXT   DS    A                   -> Next session
SEUSER   DS    CL8                 Userid
SEONDT   DS    XL8                 SMF date / time session started
SEOFFDT  DS    XL8                 SMF date / time session ended
SELU     DS    CL8                 VTAM LU assigned to session
SEIP     DS    F                   IP address of remote terminal
         DS    0D
SESIZE   EQU   *-SESSION
         SPACE 2
SMFREC   DSECT                     Generic SMF record
SMFRDW   DS    2AL2,AL1            RDW and flags
SMFRTYP  DS    FL1                 SMF record type
SMFRTME  DS    FL4                 SMF record time
SMFRDTE  DS    PL4                 SMF record date
MINSIZE  EQU   *-SMFREC
* These fields define the type 118 record (from
* Communications Server IP Configuration Reference)
         ORG   SMFREC+22
SMFHDSUB DS    AL2                 Subtype
SMFTNTCM DS    CL4                 Event type - LOGN/LOGF
SMFTNTLU DS    CL8                 LU name
SMFTNTAP DS    CL8                 Application name
SMFTNTIA DS    FL4                 Internal logical device address
SMFTNTRA DS    FL4                 Remote IP address
SMFTNTLA DS    FL4                 Local IP address
SMFTNTST DS    CL8                 Started task qualifier name
SMFTNTHN DS    CL8                 TCP/IP hoat name
         DS    XL2
SMFTNTIN DS    FL4                 Inbound byte count
SMFTNTOU DS    FL4                 Outbound byte count
SMFTNTLF DS    FL4                 LOGF specified time
SMFTNTPD DS    PL4                 LOGF date
SMFTNTRP DS    AL2                 Remote port number
SMFTNTLP DS    AL2                 Local port number
         ORG   SMFREC
         SPACE 2
         IFASMFR 30
         SPACE 2
SAVE     DSECT
         DS    F                   Reserved
HSA      DS    A                   -> Higher save area
LSA      DS    A                   -> Lower save area
R14      DS    F                   Register 14
R15      DS    F                             15
R0       DS    F                              0
R1       DS    F                               1
R2       DS    F                                2
R3       DS    F                                 3
R4       DS    F                                  4
R5       DS    F                                   5
R6       DS    F                                    6
R7       DS    F                                     7
R8       DS    F                                      8
SAVER1   DS    0F
R9       DS    F                                       9
FWORK    DS    0F
R10      DS    F                                        10
DWORK    DS    0D
R11      DS    F                                         11
R12      DS    F                                          12
         POP   PRINT
         EJECT
SCAN118  RSECT                     Return to program CSECT
SCAN118  AMODE 31
SCAN118  RMODE 24
         USING SCAN118D,11         Establish data area addressability
         USING *,12                Establish program addressability
         USING SAVE,13             Establish save area addressability
         SAVE  (14,12),,'SCAN118 &SYSDATE &SYSTIME'  Save registers
         LR    12,15               Prepare program base register
         BAS   14,*+L'*+4          Br around data srea address
         DC    AL4(SCAN118D)       Data area address
         L     11,0(,14)           Load data area base register
         LA    15,SAVEAREA         Compute new save area address
         ST    13,4(,15)           Add new save area to the
         ST    15,8(,13)            save area chain
         LR    13,15               Prepare new save area pointer
         L     2,0(,1)             Load address of the parameter text
         BAS   14,PARMSCAN         Analyze the parameter text
         BAS   14,INITHDR          Insert run date & time in page hdr
         LA    1,OPARM01           Open SYSPRINT
         BAS   14,OPENLIST
         LTR   15,15               SYSPRINT open?
         BZ    OPENSMF             Yes
         SETCC RC,16               Set RC = 16
         B     EXIT
OPENSMF  LA    1,OPARM02           Test if SMF specified in JCL
         BAS   14,TESTDD
         LTR   15,15               Test TESTDD return code
         BNZ   GETVSAM             Go find the active MAN data set
         BAS   14,OPENLIST         Open the SMF data set
         LTR   15,15               Open OK?
         BZ    TESTDCB
         SETCC RC,16
         B     EXIT
GETVSAM  L     15,CVTPTR           Load address of the CVT
         L     15,CVTSMCA-CVTMAP(,15)  Load address of the SMCA
         LA    15,(SMCAFRDS-SMCABASE)-(RDSNEXT-RDS)(,15)  Load addr   ->
                                                         of a dummy RDS
SCANRDS  ICM   15,B'1111',RDSNEXT-RDS(15)  Load addr of the next RDS
         BZ    SCANRERR            No active MAN data set
         CLI   RDSFLAG-RDS(15),0   Active?
         BNE   SCANRDS             No, try the next RDS
         MVC   ADSN,RDSDSN-RDS(15) Copy the data set to the           ->
                                    DYNALLOC parms
         LA    1,A                 Allocate the data set
         BAS   14,DYNALLOC
         LTR   15,15               Test the return code
         BNZ   EXIT
         OPEN  MF=(E,OPARM03)      Open the data set
         LTR   15,15               Open OK?
         BNZ   EXIT                No
         OI    OPTION,VSAM         Note we're using VSAM
         TIME  BIN
         ST    0,FIRSTTME
         XC    DWORK(4),DWORK
         ST    1,DWORK+4
         CVB   1,DWORK
         SR    0,0
         D     0,=F'1000'          Separate cyy and ddd
         LA    1,1900(,1)          Convert cyy to true year
         XR    1,0                 Exchange regs 0 and 1
         XR    0,1
         XR    1,0
         AHI   1,-1                Subtract 1 from ddd
         BP    DAYOK               Br if new ddd > 0
         AHI   0,-1                Subtract 1 from yyyy
         LA    1,365               Init reg 1 to Dec 31 non leap year
         LR    14,0                Copy new yyyy to reg 14
         LR    15,0                Copy new yyyy to reg 15
         NILF  14,B'11'            Is new yyyy a leap year?
*        N     14,=A(B'11')        Is new yyyy a leap year?
         BNZ   DAYOK               No
* New yyyy might be a leap year
         D     14,=F'100'          Divide new yyyy by 100
         LTR   14,14               Is new yyyy a century year?
         BNZ   ISLEAP              No, so it's a leap year
         NILF  15,B'11'            New yyyy a century year leap year?
*        N     15,=A(B'11')        New yyyy a century year leap year?
         BNZ   DAYOK               No
ISLEAP   LA    1,366
DAYOK    AHI   0,-1900             Convert new yyyy to cyy
         MHI   0,1000
         AR    1,0                 Make reg 1 cyyddd
         CVD   1,DWORK             Convert cyyddd to decimal
         ZAP   FIRSTDTE,DWORK
         LA    1,FMT12             Tell the user
         BAS   14,FMTLINE
         B     SMFLOOP
SCANRERR LA    1,FMT11             No active MAN data set found
         BAS   14,FMTLINE
         SETCC RC,16
         B     EXIT
TESTDCB  MVC   12(1,13),(DCBRECFM-IHADCB)+SMFDCB  Copy RECFM to work
         NI    12(13),DCBRECL+DCBRECCC  Isolate bits we test
         CLI   12(13),DCBRECV      RECFM = V?
         BNE   BADDCB              No
         TM    (DCBRECFM-IHADCB)+SMFDCB,DCBRECSB  RECFM=VS?
         BO    SMFLOOP             Yes, RECFM OK
BADDCB   LA    1,FMT10             Write bad DCB diagnostic
         BAS   14,FMTLINE
         SETCC RC,12               Set RC = 12
         B     EXIT                Say goodbye, Charlie
         USING SMFREC,3            Establish SMF record addressability
SMFLOOP  TM    OPTION,VSAM         Using VSAM?
         BZ    GETSEQ              No
         GET   RPL=SMFRPL          Get a record
         LTR   15,15
         BZ    LOADBUF
         DC    H'0'                Oops
LOADBUF  L     3,(RPLAREA-IFGRPL)+SMFRPL  Load address of the record
         L     0,(RPLRLEN-IFGRPL)+SMFRPL  Load the data length of the ->
                                           record we just read
         CLM   0,B'0011',0(3)      Compare the VSAM record length w/  ->
                                    record length in the presumptive  ->
                                     RDW in the presumptive SMF record
         BE    TESTEOF             Br if the RDW looks OK
         LA    1,FMT13             Write the dump header
         BAS   14,FMTLINE
         LA    0,L'RPLRLEN         Load bytes in RPLRLEN
         LA    1,(RPLRLEN-IFGRPL)+SMFRPL  Compute address of RPLRLEN
         BAS   14,DUMPREC          Dump RPLRLEN
         LA    0,32                Dump the first 32 bytes of the
         LR    1,3                  VSAM record area
         BAS   14,DUMPREC
         LHI   0,1                 Update ERRCNT
         A     0,ERRCNT
         ST    0,ERRCNT
         CHI   0,10                Test count
         BL    SMFLOOP             Br if < 10
         SETCC RC,12               Oops
         B     EXIT
TESTEOF  VBCLC 'SMFEOFMARK',(3),4  EOF?
         BE    SMFEOF              Yes
         B     GOTBUF
GETSEQ   GET   SMFDCB              Read an SMF record
         LR    3,1                 Copy the record address to reg 3
GOTBUF   LH    0,SMFRDW            Load the record length
         CHI   0,MINSIZE           Long enough?
         BL    SMFLOOP             No
         CLI   SMFRTYP,2           Type 2 (Dump start)?
         BE    SMFLOOP             Yes
         CLI   SMFRTYP,3           Type 3 (Dump end)?
         BE    SMFLOOP             Yes
         TP    SMFRDTE             Record date packed decimal?
*        TRT   SMFRDTE(L'SMFRDTE-1),TPTAB1
*        BNZ   SMFLOOP
*        TRT   SMFRDTE+L'SMFRDTE-1(1),TPTAB2
         BNZ   SMFLOOP             No
         ICM   0,B'1111',SMFRTME   Time of day valid?
         BM    SMFLOOP             No
         C     0,=A(100*24*60*60)
         BH    SMFLOOP             No
         LHI   15,1                Update RCOUNT
         A     15,RCOUNT
         ST    15,RCOUNT
         TM    OPTION,VSAM         Reading from a MAN data set?
         BZ    NOTVSAM             No
         CP    SMFRDTE,FIRSTDTE    Compare record date w/ starting date
         BL    SMFLOOP             Not interested
         BH    NOTVSAM             Date & time OK
         C     0,FIRSTTME          Time of day OK?
         BL    SMFLOOP             No
NOTVSAM  CP    SMFRDTE,LOWREC+4(4) Lowest record date / time?
         BL    NEWLOWDT
         BH    TESTHIGH
         C     0,LOWREC
         BNL   TESTHIGH
NEWLOWDT MVC   LOWREC,SMFRTME      Yes, save it
TESTHIGH CP    SMFRDTE,HIGHREC+4(4)  Highest record date / time?
         BH    NEWHIGHD
         BL    TESTRTYP
         C     0,HIGHREC
         BNH   TESTRTYP
NEWHIGHD MVC   HIGHREC,SMFRTME     Yes, save it
TESTRTYP CLI   SMFRTYP,118         Type 118 record?
         BNE   TEST30              No
         TM    OPTION,DUMPRECS     DUMPRECS option?
         BZ    NODUMP              No
         LH    0,SMFRDW            Load the record length
         LR    1,3                 Copy the record address to reg 1
         BAS   14,DUMPREC          Dump the record
NODUMP   SR    2,2                 Load the subtype
         ICM   2,B'0011',SMFHDSUB
         CHI   2,20                Telnet?
         BL    SMFLOOP             No
         CHI   2,21                Telnet?
         BH    SMFLOOP             No
         LA    1,SMFTNTLU          Obtain an LU
         BAS   14,GETLU
         USING LU,4                Establish LU addressability
         LR    4,1                 Copy the LU address to reg 4
         LA    5,LUACTP-(LUANEXT-LUACT)  Compute addr of a dummy LUACT
FINDACT  ICM   5,B'1111',LUANEXT-LUACT(5)  Load addr of the next LUACT
         BZ    GETACT                      No matching LUACT
         CLC   LUAIP-LUACT(,1),SMFTNTRA  Correct IP address?
         BNE   FINDACT             No
         CHI   2,20                LOGON event?
         BNE   TESTOFF             No
         OC    LUAONDT-LUACT(,1),LUAONDT-LUACT(1)  LUACT already on?
         BNZ   FINDACT                             No
         B     GOTACT              Yes
TESTOFF  OC    LUAOFFDT-LUACT(,1),LUAOFFDT-LUACT(1) LUACT already off?
         BNZ   FINDACT                              No
         B     GOTACT
GETACT   LA    0,LUASIZE           Allocate an LUACT
         BAS   14,GETMAIN
         XC    0(LUASIZE,1),0(1)   Initialize the LUACT
         MVC   LUANEXT-LUACT(,1),LUACTP  Add the LUACT to the
         ST    1,LUACTP                   LUACT chain
         MVC   LUAIP-LUACT(,1),SMFTNTRA  Copy IP address to the LUACT
         ST    4,LUALU-LUACT(,1)   Store the LU address in the LUACT
         LHI   0,1
         A     0,LUCOUNT
         ST    0,LUCOUNT
GOTACT   CLC   SMFTNTCM,=C'LOGN'   LOGN event?
         BNE   ISOFF               No
         MVC   LUAONDT-LUACT(,1),SMFRTME
         B     SMFLOOP             Continue on
ISOFF    CLC   SMFTNTCM,=C'LOGF'   LOGF event?
         BE    LOGOFF              Yes
         TM    OPTION,DUMPRECS     Record already dumped?
         BO    SKIPDUMP            Yes, dump it just once
         LH    0,SMFRDW            Dump the record
         LR    1,3
         BAS   14,DUMPREC
SKIPDUMP SETCC RC,4                Set RC = 4
         B     SMFLOOP
LOGOFF   MVC   LUAOFFDT-LUACT(,1),SMFRTME  Save the date & time
         B     SMFLOOP
TEST30   CLI   SMFRTYP,30          Type 30 record?
         BNE   SMFLOOP             No
         USING SMFRCD30,3          Reestablish addressability
         SR    0,0                 Load the record
         ICM   0,B'0011',SMF30STP   sub type
         CHI   0,5                 Subtype 5 (end of job / LOGOFF)?
         BNE   SMFLOOP             No, not interested
         ICM   5,B'1111',SMF30IOF  Load offset of the ID section
         BZ    SMFLOOP             Br if no ID section
         AR    5,3                 Compute address of the ID section
         USING SMF30ID,5           Establish ID area addressability
         CLI   SMF30JNM,C'T'       TSO session?
         BNE   SMFLOOP             No
         TP    SMF30RSD            Reader date packed decimal?
*        TRT   SMF30RSD(L'SMF30RSD-1),TPTAB1
*        BNZ   BAD30
*        TRT   SMF30RSD+L'SMF30RSD-1(1),TPTAB2
         BNZ   BAD30               No
         ICM   0,B'1111',SMF30RST  Load reader time
         BM    BAD30               Oops
         C     0,=A(100*24*60*60)  Reader time valid?
         BNH   GOOD30              Yes
BAD30    LH    0,SMFRDW-SMFREC(,3) Load the record length
         LR    1,3                 Copy the record address to reg 1
         BAS   14,DUMPREC          Dump the record
         SETCC RC,4                Set RC = 4
         B     SMFLOOP             Get the next record
GOOD30   MVC   FMTWORK(L'SMF30JBN),SMF30JBN  Prepare the SESSION key
         MVC   FMTWORK+L'SMF30JBN(L'SMF30RST+L'SMF30RSD),SMF30RST
         LA    1,FMTWORK           Obtain a SESSION
         BAS   14,GETSESS
         LR    4,1                 Copy the address to reg 4
         USING SESSION,4
         MVC   SEUSER,SMF30RUD     Fill in SESSION data
         MVC   SEOFFDT,SMFRTME-SMFREC(3)  LOGOFF date / time
         MVC   SELU,SMF30TSN       VTAM LU name
         B     SMFLOOP
         DROP  3,4,5
SMFEOF   NOPR  0
         ICM   0,B'1111',RCOUNT    Any SMF data?
         BNZ   EOF0100             Yes
         LA    1,FMT03
         BAS   14,FMTLINE
         SETCC RC,12
         B     EXIT
* Add session start and end times to any orphaned LUACTs
EOF0100  LHI   0,HASHNUM           Load number of HASHTAB entries
         LA    2,HASHTAB           Compute addr of first HASHTAB entry
EOF0200  LR    1,2                 Copy address to reg 1
EOF0300  ICM   1,B'1111',LUNEXT-LU(1)  Load addr of the next LU
         BZ    EOF0600             Br if end of LU chain
         LA    15,(LUACTP-LU)-(LUANEXT-LUACT)(,1)  Load address of a  ->
                                                    dummy LUACT
EOF0400  ICM   15,B'1111',LUANEXT-LUACT(15)  Load address of the      ->
                                              next LUACT
         BZ    EOF0300             Br if no more LUACTs
         OC    LUAONDT-LUACT(,15),LUAONDT-LUACT(15)  Connect date?
         BNZ   EOF0500                                Yes
         MVC   LUAONDT-LUACT(,15),LOWREC  Copy lowest record date
EOF0500  OC    LUAOFFDT-LUACT(,15),LUAOFFDT-LUACT(15)  Disconnect date?
         BNZ   EOF0400                                 Yes
         MVC   LUAOFFDT-LUACT(,15),HIGHREC  Copy highest record date
         B     EOF0400
EOF0600  AHI   2,4
         BCT   0,EOF0200
* Build a single session list from SESSTAB
         USING SESSION,1
         LHI   0,SESSNUM           Load number of SESSTAB entries
         LA    2,SESSTAB           Compute addr of first SESSTAB entry
EOF0700  ICM   1,B'1111',0(2)      Load SESSION address
         BZ    EOF0800             End of list
         MVC   0(4,2),SENEXT       Remove SESSION from SESSTAB
         MVC   SENEXT,SELIST       Add SESSION to SESSION list
         ST    1,SELIST
         B     EOF0700
EOF0800  AHI   2,4                 Compute addr of next SESSTAB entry
         BCT   0,EOF0700
         DROP  1
         LA    1,LOWREC            Convert time to
         BAS   14,CNVTBIN           unsigned packed decimal
         LA    1,HIGHREC           Convert time to
         BAS   14,CNVTBIN           unsigned packed decimal
         LA    0,FMTWORK
         LA    1,FMT04             Write SMF DATA FROM ... TO ...
         L     15,=V(MINIFMT)
         CALL  (15)
         LR    0,1                 Copy the address to reg 0
         LH    1,0(,1)             Load the length
         LA    14,SUBHDR           Load addr of the subheader buffer
         LR    15,1                Copy the length to reg 15
         MVCL  14,0                Copy the sub header
* Match the TSO sesssions with an LUACT
         USING SESSION,4
         USING LUACT,3
         LA    4,SELIST-(SENEXT-SESSION)  Losd address of dummy SESSION
MATCH100 ICM   4,B'1111',SENEXT    Load address of next SESSION
         BZ    MATCH500            Done
*        LA    0,SESIZE
*        LR    1,4
*        BAS   14,DUMPREC
         LA    1,SELU              Find the LU for this session
         BAS   14,FINDLU
         LTR   15,15               LU found?
         BNZ   MATCH100            No
*        LR    2,1
*        LA    0,LUSIZE
*        BAS   14,DUMPREC
*        LR    1,2
         L     5,=A(X'7FFFFFFF')   Initialize minimum time
         SR    6,6                 Initialize best LUACT
         LA    3,(LUACTP-LU)-(LUANEXT-LUACT)(,1)  Load address of a   ->
                                                   dummy LUACT
MATCH200 ICM   3,B'1111',LUANEXT   Load address of next LUACT
         BZ    MATCH400            Done
*        LA    0,LUASIZE
*        LR    1,3
*        BAS   14,DUMPREC
*        L     1,LUALU             Load address of the LU
*        CLC   LUNAME-LU(,1),SELU  LU match?
*        BNE   MATCH200            No
         CMPDT LUAONDT,SEONDT,MATCH300,MATCH200  LU started before TSO?
MATCH300 DC    0H'0'               LU started before TSO
         L     15,=V(SMFETIME)     Compute time between connect &     ->
                                    TSO logon
         CALL  (15),(LUAONDT,SEONDT),MF=(E,EPARM)
         C     5,DUR               Compare min so far with this time
         BNH   MATCH200            Not this LUACT
         L     5,DUR               Load minimum time
         LR    6,3                 Save the LUACT address
         B     MATCH200            Keep looking
MATCH400 LTR   6,6                 Any LUACTs look OK?
         BZ    MATCH100            No
         MVC   SEIP,LUAIP-LUACT(6) Copy IP to SESSION
         B     MATCH100            Goto next SESSION
         DROP  3,4
* Remove the LUs from the hash table and build a single LUACT chain
MATCH500 LHI   0,HASHNUM
         LA    2,HASHTAB
         USING LU,1
BACT100  ICM   1,B'1111',0(2)      Load addr of the next LU
         BZ    BACT300             No more LUs
         MVC   0(4,2),LUNEXT       Remove the LU from the hash table
         MVC   LUNEXT,LULIST       Add the LU to the list
         ST    1,LULIST
BACT200  ICM   3,B'1111',LUACTP            Load addr of the next LUACT
         BZ    BACT100                     All LUACTs checked
         MVC   LUACTP,LUANEXT-LUACT(3)     Remove LUACT from LU
         MVC   LUANEXT-LUACT(,3),ACTLIST   Add LUACT to ACTLIST
         ST    3,ACTLIST
         B     BACT200
BACT300  AHI   2,4
         BCT   0,BACT100
         DROP  1
* Sort the LUACTs by date & time
         L     15,=V(QSORTL)
         CALL  (15),(ACTLIST),MF=(E,SORTPARM)
* Sort the TSO sessions
         LA    2,SORTCMP3
         TM    OPTION,SORTTIME
         BO    SESORT
         LA    2,SORTCMP4
         TM    OPTION,SORTUSER
         BO    SESORT
         LA    2,SORTCMP5
SESORT   L     15,=V(QSORTL)
         CALL  (15),(SELIST,,(2)),MF=(E,SORTPARM)
* List the TSO sessions
         MVI   CC,C'1'
         USING SESSION,4
         LA    4,SELIST-(SENEXT-SESSION)
RPT0100  ICM   4,B'1111',SENEXT    Load address of the next SESSION
         BZ    RPT0500             Done
         L     15,=V(SMFETIME)     Compute the elapsed time
         CALL  (15),(SEONDT,SEOFFDT),MF=(E,EPARM)
         BAS   14,GENDTIME
* Now list the session data
         LA    1,SEONDT
         BAS   14,CNVTBIN
         LA    1,SEOFFDT
         BAS   14,CNVTBIN
         MVI   IPADDR,C' '         Clear translated IP address
         MVC   IPADDR+1(L'IPADDR-1),IPADDR
         ICM   0,B'1111',SEIP      Load binary IP address
         BZ    RPT0400             No address
         LA    1,IPADDR            Convert IP address to text
         BAS   14,FMTIP
         L     1,SEIP              Get an IP for this address
         BAS   14,GETIP
         LR    5,1                 Copy the IP address to reg 5
         LA    15,IPULIST-IP(,5)   Load address of a dummy user
RPT0200  ICM   15,B'1111',0(15)    Load address of the next user
         BZ    RPT0300             Br if user not using this IP
         CLC   SEUSER,4(15)        User using this IP?
         BE    RPT0400             Yes
         B     RPT0200             Try again
RPT0300  LA    0,16                Allocate a new user
         BAS   14,GETMAIN
         MVC   4(L'SEUSER,1),SEUSER  Copy the userid to the user
         MVC   0(4,1),IPULIST-IP(5)  Add the user to the IP
         ST    1,IPULIST-IP(,5)
RPT0400  LA    1,FMT06             Write TSO session data
         BAS   14,FMTLINE
         MVI   CC,C' '
         B     RPT0100
         DROP  4
* Now list the LUACTs sorted by date & time
RPT0500  NOPR  0
         TM    OPTION,SESSOPT
         BZ    RPT0600
         LA    1,FMT07
         BAS   14,FMTLINE
         BAS   14,REPORT
RPT0600  L     15,=V(QSORTL)       Sort the LUACTs by IP address
         CALL  (15),(ACTLIST,,SORTCMP2),MF=(E,SORTPARM)
* Build a list of IP addresses with a count
OLD      USING LUACT,2
NEW      USING LUACT,3
         ICM   2,B'1111',ACTLIST   Load address of the first LUACT
         BZ    RPT2000             Br if none
         LR    3,2                 Init reg 3
RPT0700  LHI   4,1                 Init the counter
RPT0800  ICM   3,B'1111',NEW.LUANEXT  Load address of the next LU
         BZ    RPT1000             Exit if end of chain
         CLC   OLD.LUAIP,NEW.LUAIP Same IP?
         BNE   RPT0900             No
         AHI   4,1                 Add 1 to the counter
         B     RPT0800             Do it again
RPT0900  LHI   0,LUCSIZE           Allocate a new LUC
         BAS   14,GETMAIN
         XC    0(LUCSIZE,1),0(1)   Clear the LUC
         L     15,LUCLIST+4        Add the LUC to the end of the LUCs
         ST    1,LUCNEXT-LUC(,15)
         ST    1,LUCLIST+4
         ST    4,LUCCOUNT-LUC(,1)
         MVC   LUCIP-LUC(,1),OLD.LUAIP  Copy the IP address to the LUC
         LR    2,3                 Reset the "old" LU
         B     RPT0700
RPT1000  LA    0,LUCSIZE           Allocate the last LUC
         BAS   14,GETMAIN
         XC    0(LUCSIZE,1),0(1)   Clear the LUC
         ST    4,LUCCOUNT-LUC(,1)  Add the LUC to the LUC list
         MVC   LUCIP-LUC(,1),OLD.LUAIP
         L     15,LUCLIST+4
         ST    1,LUCNEXT-LUC(,15)
         DROP  OLD,NEW
         L     15,=V(QSORTL)       Sort the LUCs by use count
         CALL  (15),(LUCLIST,,SORTCMP6),MF=(E,SORTPARM)
         LA    1,FMT08             Write the header
         BAS   14,FMTLINE
         LHI   3,100               Just list the top 100
RPT1100  LA    2,LUCLIST-(LUCNEXT-LUC)  Load addr of a dummy LUC
         USING LUC,2               Establish LUC addressability
RPT1200  ICM   2,B'1111',LUCNEXT   Load address of the next LUC
         BZ    RPT1300             Done
         L     0,LUCIP             Convert the
         LA    1,IPADDR             IP address to text
         BAS   14,FMTIP
         LA    1,FMT09             Write the LUC
         BAS   14,FMTLINE
         BCT   3,RPT1200
         DROP  2
* Remove the IPs from IPTAB, chain IPs with more than 1 user on IPLIST
RPT1300  LA    0,IPNUM
         LA    2,IPTAB
RPT1400  ICM   1,B'1111',0(2)
         BZ    RPT1500
         MVC   0(4,2),IPNEXT-IP(1)
         ICM   15,B'1111',IPULIST-IP(1)
         BZ    RPT1400
         ICM   15,B'1111',0(15)
         BZ    RPT1400
         MVC   0(4,1),IPLIST
         ST    1,IPLIST
         B     RPT1400
RPT1500  LA    2,4(,2)
         BCT   0,RPT1400
         ICM   0,B'1111',IPLIST    Any IPs?
         BZ    RPT2000             No
         L     15,=V(QSORTL)       Sort the IPs
         CALL  (15),(IPLIST,,SORTCMP7),MF=(E,SORTPARM)
         LA    1,FMT14             Write the header line
         BAS   14,FMTLINE
         LA    2,IPLIST-(IPNEXT-IP)
RPT1600  ICM   2,B'1111',IPNEXT-IP(2)  Load next IP
         BZ    RPT2000                 None left
         MVI   FMTWORK+4,C' '      Prepare line in FMTWORK
         LA    1,FMTWORK+5
         L     0,IPV4ADDR-IP(,2)
         BAS   14,FMTIP            Convert the address
         L     15,=V(QSORTL)       Sort the user list
         CALL  (15),(IPULIST-IP(,2),,SORTCMP8),MF=(E,SORTPARM)
         LA    3,FMTWORK+5+L'IPADDR  Address of first user
         LH    4,(DCBLRECL-IHADCB)+PRINT  Load max LRECL
         LA    4,FMTWORK(4)        Compute address of end of line
         LA    5,IPULIST-IP(,2)    Address of dummy user
RPT1700  ICM   5,B'1111',0(5)      Next user
         BZ    RPT1900             End of user list
         LA    15,9(,3)            Compute trial end of the user cell
         CR    15,4                User cell fit in line?
         BNH   RPT1800             Yes
         LA    1,FMTWORK           Write the line
         SR    3,1
         SLL   3,16
         ST    3,FMTWORK
         BAS   14,OUTEDIT
         MVC   FMTWORK+5(30),FMTWORK+4  Prepare to start a new line
         LA    3,FMTWORK+5+L'IPADDR
RPT1800  MVI   0(3),C' '           Add user cell to the line
         MVC   1(8,3),4(5)
         LA    3,9(,3)             Address of next cell
         B     RPT1700
RPT1900  LA    1,FMTWORK           Write the last line for the IP
         SR    3,1
         SLL   3,16
         ST    3,FMTWORK
         BAS   14,OUTEDIT
         B     RPT1600             Get the next IP
RPT2000  BAS   14,LISTOPT
EXIT     BAS   14,FREEALL          Free storage allocated by GETMAIN
         LA    1,CPARM01           Close SYSPRINT
         BAS   14,CLOSELST
         LA    1,CPARM02           Close SMF
         BAS   14,CLOSELST
         TM    OPTION,VSAM         Using a MAN data set?
         BZ    RETURN              Br if not
         CLOSE MF=(E,CPARM03)      Close the MAN data set
RETURN   SR    15,15               Load the return code
         IC    15,RC
         L     13,4(,13)           Load addr of the higher save area
         RETURN (14,12),T,RC=(15)  Restore registers & return
         EJECT
* Calculste session duration, store result in DTIME
         USING LUACT,2
         CNOP  0,8
DURATION BASR  15,0
         SAVE  (14,3),,DURATION    Save registers
         LA    15,72(,13)          Compute new save area address
         ST    13,4(,15)           Add new save area to the
         ST    15,8(,13)            save area chain
         LR    13,15               Prepare new save area pointer
         LR    2,1                 Save reg 1
         L     15,=V(SMFETIME)     Load address of SMFETIME
         CALL  (15),(LUAONDT,LUAOFFDT),MF=(E,EPARM)  Compute elapsed  ->
                                                      time
         BAS   14,GENDTIME         Convert elapsed time to hhhhh:mm
         L     13,4(,13)           Load address of the higher save area
         RETURN (14,3)             Restore registers & return
         DROP  2
         EJECT
* Generate hhhhh:mm from a time duration
         USING SAVE,13
         CNOP  0,8
GENDTIME BASR  15,0                Store current asddress in reg 15
         SAVE  14,,GENDTIME        Save reg 14
         SR    0,0                 Convert elapsed time to minutes
         L     1,DUR
         D     0,=A(100*60)
         SR    0,0                 Convert minutes to hours & minutes
         D     0,=A(60)
         MHI   1,100               Multiply minutes by 100
         AR    1,0                 Add seconds to minutes
         CVD   1,DWORK             Convert composite hhmm to decimal
         MVC   DTIME,DMASK         Convert composite hhhhhmm to digits
         ED    DTIME,DWORK+4
         RETURN 14                 Restore reg 14 & return
         DROP  13
         EJECT
         CNOP  0,8
GETIP    BASR  15,0
         SAVE  (14,3),,GETIP
         LR    3,1
         SR    0,0
         D     0,=A(IPNUM)
         SLL   0,2
         LR    2,0
         LA    2,IPTAB(2)
         LR    1,2
GETIP100 ICM   1,B'1111',IPNEXT-IP(1)
         BZ    GETIP200
         C     3,IPV4ADDR-IP(,1)
         BNE   GETIP100
         B     GETIP300
GETIP200 LA    15,72(,13)
         ST    13,4(,15)
         ST    15,8(,13)
         LR    13,15
         LA    0,IPSIZE
         BAS   14,GETMAIN
         XC    0(IPSIZE,1),0(1)
         ST    3,IPV4ADDR-IP(,1)
         MVC   IPNEXT-IP(,1),0(2)
         ST    1,0(,2)
         L     13,4(,13)
GETIP300 ST    1,R1-SAVE(,13)
         RETURN (14,3)
         EJECT
* Locate a SESSION, allocate and initialize a new SESSION if necessary
         USING SAVE,13
         CNOP  0,8
GETSESS  BASR  15,0
         SAVE  (14,3),,GETSESS     Save registers
         LR    3,1                 Copy address of key to reg 3
         PACK  DWORK(5),0(9,1)     Compact the job name
         SR    0,0
         L     1,DWORK             Load compacted job name
         AL    1,8(,3)             Add logon time and
         AL    1,12(,3)             and logon date
         D     0,=A(SESSNUM)       Divide key by entries in SESSTAB
         LR    2,0                Compute addr of SESSTAB entry for key
         SLL   2,2
         LA    2,SESSTAB(2)
         LR    1,2
GETS0100 ICM   1,B'1111',SENEXT-SESSION(1)  Load addr of next SESSION
         BZ    GETS0200            No SESSION matches key
         CLC   SEUSER-SESSION(,1),0(3)  Test key
         BNE   GETS0100
         CLC   SEONDT-SESSION(,1),8(3)
         BNE   GETS0100
         B     GETS0300            Key matches
GETS0200 LA    15,72(,13)          Add new save area to the
         ST    13,4(,15)            save area chain
         ST    15,8(,13)
         LR    13,15
         LA    0,SESIZE            Allocate storage for a new SESSION
         BAS   14,GETMAIN
         XC    0(SESIZE,1),0(1)    Clear the SESSION
         MVC   SEUSER-SESSION(,1),0(3)  Copy the key to the
         MVC   SEONDT-SESSION(,1),8(3)   new SESSION
         MVC   SENEXT-SESSION(,1),0(2)  Add the SESSION to SESSTAB
         ST    1,0(,2)
         LHI   0,1                 Update SECOUNT
         A     0,SECOUNT
         ST    0,SECOUNT
         L     13,4(,13)           Load addr of the higher save area
GETS0300 ST    1,R1                Replace caller's reg 1 w/ SESSION
         RETURN (14,3)             Restore registers & return
         DROP  13
         EJECT
* Get an LU using the LU name and IP address as a key
         USING SAVE,13
         CNOP  0,8
GETLU    BASR  15,0                Store curremt address in reg 15
         SAVE  (14,3),,GETLU       Save registers
         LR    3,1                 Copy key address to reg 3
         PACK  DWORK(5),0(9,1)     Compact the key
         SR    0,0                 Divide compacted key
         L     1,DWORK              by the number of entries
         D     0,=A(HASHNUM)         in HASHTAB
         LR    2,0                 Copy the remainder to reg 2
         SLL   2,2                 Multiply the remainder by 4
         LA    2,HASHTAB(2)        Compute address of a HASHTAB entry
         LR    1,2                 Copy HASHTAB entry address to reg 1
GLU0100  ICM   1,B'1111',LUNEXT-LU(1)  Load address of the next LU
         BZ    GLU0200             No more LUs remain
         CLC   LUNAME-LU(,1),0(3)  LU name = key?
         BNE   GLU0100             No, try again
         B     GLU0300             We got the right LU
GLU0200  LA    15,72(,13)          Compute addr of the next save area
         ST    13,4(,15)           Add new save area to the
         ST    15,8(,13)            save area chain
         LR    13,15               Prepare the new save area pointer
         LA    0,LUSIZE            Allocate storage for a new LU
         BAS   14,GETMAIN
         L     13,4(,13)           Load address of the higher save area
         XC    0(LUSIZE,1),0(1)    Clear the new LU
         MVC   LUNAME-LU(,1),0(3)  Copy the LU name to the new LU
         MVC   LUNEXT-LU(,1),0(2)  Add the new LU to the hash table
         ST    1,0(,2)
GLU0300  ST    1,R1                Replace caller's reg 1 with the    ->
                                    LU address
         RETURN (14,3)             Restore registers & return
         EJECT
         CNOP  0,8
FINDLU   BASR  15,0                Store current address in reg 15
         SAVE  (14,0),,FINDLU      Save registers
         PACK  DWORK(5),0(9,1)     Compact the LU name
         SR    14,14               Divide compacted LU name
         L     15,DWORK             by the number of hash
         D     14,=A(HASHNUM)        table entries
         LR    15,14               Copy the remainder to reg 1
         SLL   15,2                Multiply remainder by 4
         LA    15,HASHTAB(15)     Compute address of a hash table entry
FLU0100  ICM   15,B'1111',LUNEXT-LU(15)  Load address of the next LU
         BZ    FLU0200             Br if not found
         CLC   LUNAME-LU(,15),0(1) LU name match?
         BNE   FLU0100             No, try again
         ST    15,R1               Replace caller's reg 1 with LU addr
         RETURN (14,1),RC=0        Restore registers & return
FLU0200  ST    15,R1              Replace caller's reg 1 with binary 0s
         RETURN (14,1),RC=4        Restore registers & return
         DROP  13
         EJECT
* List LUACTs
         CNOP  0,8
REPORT   BASR  15,0                Store current address in reg 15
         SAVE  (14,12),,REPORT     Save registers
         LA    15,72(,13)          Compute new save area address
         ST    13,4(,15)           Add new save area to the
         ST    15,8(,13)            save area chain
         LR    13,15               Prepare new save area pointer
         MVI   CC,C' '
         LA    4,ACTLIST-(LUANEXT-LUACT)  Compute address of a        ->
                                           dummy LUACT
         USING LUACT,4
RPTR1000 ICM   4,B'1111',LUANEXT   Load address of the next LUACT
         BZ    RPTR1100            End of LUACT list
         LR    1,4                 Copy the LUACT address to reg 1
         BAS   14,DURATION         Compute the active time
         MVC   XLOW,LUAONDT        Copy the start and end times to
         MVC   XHIGH,LUAOFFDT       work areas
         LA    1,XLOW              Convert time of day to unsigned
         BAS   14,CNVTBIN           packed decimal digits
         LA    1,XHIGH             Convert time of day to unsigned
         BAS   14,CNVTBIN           packed decimal digits
         L     0,LUAIP             Convert the 32 bit IP V4 address
         LA    1,IPADDR             to xxx.xxx.xxx.xxx
         BAS   14,FMTIP
         L     3,LUALU             Now list the LUACT
         LA    1,FMT02
         BAS   14,FMTLINE
         MVI   CC,C' '
         B     RPTR1000            Go list the next LUACT
         DROP  4
RPTR1100 L     13,4(,13)           Load address of the higher save area
         RETURN (14,12)            Restore registers & return
         EJECT
* Format a 32-bit binary IP address as nnn.nnn.nnn.nnn
         USING SAVE,13
         CNOP  0,8
FMTIP    BASR  15,0                Store current address in reg 15
         SAVE  (14,3),,FMTIP       Save registers
         LR    2,1                 Copy output address to reg 2
         MVI   0(2),C' '           Set output area to blanks
         MVC   1(14,2),0(2)
         LR    1,0                 Copy binary IP address to reg 1
         LA    15,4                Load number of groups
FMTIP100 SR    0,0                 Set reg 0 = 0
         SLDL  0,8                 Shift 8 bits into reg 0
         CVD   0,DWORK             Convert to decimal
         ST    1,SAVER1            Save reg 1
         MVC   FWORK,=X'40202120'  Init digit area
         LA    1,FWORK+3           Init reg 1
         EDMK  FWORK,DWORK+6       Convert decimal to digits
         LA    3,FWORK+4           Compute address of end of digits
         SR    3,1                 Compute digits in FWORK
         LR    0,1                 Copy start of digits in FWORK to   ->
                                    reg 0
         LR    1,3                 Copy number of digits to reg 1
         MVCL  2,0                 Copy digits to output
         IC    14,0(,2)            Save 1 byte
         MVI   0(2),C'.'           Add a .
         LA    2,1(,2)             Update output pointer
         L     1,SAVER1            Reload reg 1
         BCT   15,FMTIP100         Do the next group
         BCTR  2,0                 Restore the byte
         STC   14,0(,2)
         RETURN (14,3)             Restore registers & return
         DROP  13
         EJECT
* Convert an SMF binary time of day to an 8 digit unsigned
* "packed decimal" "value" for MINIFMT
         CNOP  0,8
CNVTBIN  BASR  15,0                Store current address in reg 15
         SAVE  (14,2),,CNVTBIN     Save registers
         LA    15,72(,13)          Compute new save area address
         ST    13,4(,15)           Add new save area to the
         ST    15,8(,13)            save area chain
         LR    13,15               Prepare new save area pointer
         LR    2,1                 Copy time of day address to reg 2
         ICM   0,B'1111',0(1)      Load the time of day
         L     15,=V(CNVTBIN)      Load address of CNVTBIN in MINIFMT
         CALL  (15)                Convert binary time of day
         STCM  0,B'1111',0(2)      Ewplace binary time of day w/ digits
         L     13,4(,13)           Load address of the higher save area
         RETURN (14,2)             Restore registers & return
         EJECT
* Insert the run date & time into the page header
         CNOP  0,8
INITHDR  BASR  15,0                Store current address in reg 15
         SAVE  (14,0),,INITHDR     Save registers
         LA    15,72(,13)          Compute addr of the next save area
         ST    13,4(,15)           Add new save area to the
         ST    15,8(,13)            save area chain
         LR    13,15               Establish new save area pointer
         LA    0,FMTWORK           Load addr of the MINIFMT work area
         LA    1,FMT01             Load addr of the format
         L     15,=V(MINIFMT)      Load addr of the format program
         CALL  (15)                Format the system date & time
         LA    0,4(,1)             Compute addr of the date & time text
         LH    15,0(,1)            Load length of the message
         AHI   15,-4               Compute length of the next
         LA    14,PAGEHDR+97       Compute addr of date & time in hdr
         LR    1,15                Copy length to reg 1
         MVCL  14,0                Copy date & time to the page hdr
         L     13,4(,13)           Load addr of the higher save area
         RETURN (14,0),T           Restore registers & return
         EJECT
* Open one or more data sets
         CNOP  0,8
OPENLIST BASR  15,0                Store current address in reg 15
         SAVE  (14,2),,OPENLIST    Save registers
         LR    2,1                 Copy parm list addr to reg 2
         OPEN  MF=(E,(2))          Open the DCBs
         SR    15,15               Set preliminary return code
OL0100   L     1,0(,2)             Load a DCB address
         N     1,=A(X'FFFFFF')     Isolate the 24-bit DCB address
         TM    DCBOFLGS-IHADCB(1),DCBOFOPN  Test if the DCB is open
         JO    *+8                 Br if so
         LHI   15,4                Reset the return code
         TM    0(2),X'80'          Test if end of the parm list
         LA    2,4(,2)             Compute addr of the next DCB pointer
         JZ    OL0100              Br if not end of the parm list
         RETURN (14,2),T,RC=(15)   Restore regs & return
         EJECT
* Close one or more data sets and free their buffer pools
         CNOP  0,8
CLOSELST BASR  15,0                Store current address in reg 15
         SAVE  (14,2),,CLOSELST    Save registers
         LR    2,1                 Copy parm list address to reg 2
         CLOSE MF=(E,(1))          Close the DCBs
CL0100   L     1,0(,2)             Load a DCB addr from the parm list
         N     1,=A(X'FFFFFF')     Isolate the 24-bit DCB address
         TM    DCBOFLGS-IHADCB(1),DCBOFOPN  Test if the DCB is open
         JO    CL0200              Br if so
         TM    (DCBBUFCB-IHADCB)+3(1),1  Test if there is a buffer pool
         JO    CL0200              Br if not
         FREEPOOL (1)              Free the buffer pool
CL0200   TM    0(2),X'80'          Test if end of the parm list
         LA    2,4(,2)             Compute addr of the next DCB pointer
         JZ    CL0100              Br if not end of the parm list
         RETURN (14,2),T           Restore registers & return
         EJECT
* Use MINIFMT to prepare an output line, then "print" it using OUTEDIT
         CNOP  0,8
FMTLINE  BASR  15,0                Store current address in reg 15
         SAVE  14,,FMTLINE         Save reg 14
         LA    15,72(,13)          Compute addr of the next save area
         ST    15,8(,13)           Add new save area to the
         ST    13,4(,15)            save area chain
         LR    13,15               Establish new save area pointer
         LA    0,FMTWORK           Load addr of the MINIFMT work area
         L     15,=V(MINIFMT)      Load addr of MINIFMT
         CALL  (15)                Format the line
         BRAS  14,OUTEDIT          Write the formatted line
         L     13,4(,13)           Load addr of the higher save area
         RETURN 14,T               Restore reg 14 & return
         EJECT
* "Print" a line and insert a page header as required
         CNOP  0,8
OUTEDIT  BASR  15,0                Store current address in reg 15
         SAVE  (14,4),,OUTEDIT     Save registers
         LR    2,1                 Copy line address to reg 2
         SR    3,3                 Set reg 3 = 0
         SR    4,4                 Set reg 4 = 0
         LA    15,72(,13)          Compute addr of the next save area
         ST    15,8(,13)           Add new save area to the
         ST    13,4(,15)            save area chain
         LR    13,15               Establish new save area pointer
*        LH    0,0(,2)             Load the line length
*        CH    0,(DCBLRECL-IHADCB)+PRINT  Test the length
*        JNH   *+L'*+6             Br if length <= lrecl
*        MVC   0(2,2),(DCBLRECL-IHADCB)+PRINT  Reset the length
         IC    3,4(,1)             Load the carriage control character
         IC    4,OELINES(3)        Load lines this line will print
         AH    4,LINECT            Add current page position
         CHI   4,60                Compare new page position with     ->
                                    max lines on a page
         JNH   OE0100              Br if new line will fit on the     ->
                                    current page
         AP    PAGENUM,=P'1'       Add 1 to the page number
         MVC   PAGE#,=X'402020202120'  Convert page number to digits
         ED    PAGE#,PAGENUM
         PUT   PRINT,PAGEHDR       Write the page header
         MVI   4(2),C'0'           Replace the carriage control
         LHI   4,3                 Set new page position
         SR    15,15               Load data length of the sub header
         ICM   15,B'0011',SUBHDR
         BZ    OE0100              Br if no sub header
         SR    15,15               Load the carriage control character
         IC    15,SUBHDR+4
         IC    15,OELINES(15)      Load line the subheader prints
         AR    4,15                Compute actual position of the     ->
                                    first text line
         PUT   PRINT,SUBHDR        Write the sub header
OE0100   PUT   PRINT,(2)           Write the line
         STH   4,LINECT            Update the page position
         STC   3,4(,2)             Restore original carriage control
         L     13,4(,13)           Load addr of the higher save area
         RETURN (14,4),T           Restore registers & return
         EJECT
* QSORTL compare exits
         CNOP  0,8
SORTCMP1 J     XXXXCMP1
SORTCMP2 J     XXXXCMP2
SORTCMP3 J     XXXXCMP3
SORTCMP4 J     XXXXCMP4
SORTCMP5 J     XXXXCMP5
SORTCMP6 J     XXXXCMP6
SORTCMP7 J     XXXXCMP7
SORTCMP8 J     XXXXCMP8
PARMSCAN J     XXXXSCAN
TESTDD   J     XXXXTDD
DYNALLOC J     XXXALLOC
DUMPREC  J     XXXXDUMP
GETMAIN  J     XXXXGETM
FREEALL  J     XXXXFREE
LISTOPT  J     XXXXLOPT
         CNOP  0,8
L        USING LUACT,14
R        USING LUACT,1
XXXXCMP1 SAVE  14
         LM    14,15,0(1)
         L     14,0(,14)
         L     1,0(,15)
         LHI   15,1
         CMPDT L.LUAONDT,R.LUAONDT,SC0200,SC0300
         CMPDT L.LUAOFFDT,R.LUAOFFDT,SC0200,SC0300
         L     14,L.LUALU
         L     1,R.LUALU
*        CLC   L.LUNAME,R.LUNAME
         CLC   LUNAME-LU(,14),LUNAME-LU(1)
         JL    SC0200
         JH    SC0300
         J     SC0100
         SPACE 2
         CNOP  0,8
XXXXCMP2 SAVE  14
         LM    14,15,0(1)
         L     14,0(,14)
         L     1,0(,15)
         LHI   15,1
         L     0,L.LUAIP
         CL    0,R.LUAIP
         JL    SC0200
         JH    SC0300
         CMPDT L.LUAONDT,R.LUAONDT,SC0200,SC0300
         J     SC0100
         DROP  L,R
         SPACE 2
         CNOP  0,8
L        USING SESSION,14
R        USING SESSION,1
XXXXCMP3 SAVE  14
         LM    14,15,0(1)
         L     14,0(,14)
         L     1,0(,15)
         LHI   15,1
         CMPDT L.SEONDT,R.SEONDT,SC0200,SC0300
         CLC   L.SEUSER,R.SEUSER
         JL    SC0200
         JH    SC0300
         J     SC0100
         SPACE 2
         CNOP  0,8
XXXXCMP4 SAVE  14
         LM    14,15,0(1)
         L     14,0(,14)
         L     1,0(,15)
         LHI   15,1
         CLC   L.SEUSER,R.SEUSER
         JL    SC0200
         JH    SC0300
         CMPDT L.SEONDT,R.SEONDT,SC0200,SC0300
         J     SC0100
         SPACE 2
XXXXCMP5 SAVE  14
         LM    14,15,0(1)
         L     14,0(,14)
         L     1,0(,15)
         LHI   15,1
         L     0,L.SEIP
         CL    0,R.SEIP
         JL    SC0200
         JH    SC0300
         CLC   L.SEUSER,R.SEUSER
         JL    SC0200
         JH    SC0300
         CMPDT L.SEONDT,R.SEONDT,SC0200,SC0300
         J     SC0100
         DROP  L,R
         SPACE 2
         CNOP  0,8
L        USING LUC,14
R        USING LUC,1
XXXXCMP6 SAVE  14
         LM    14,15,0(1)
         L     14,0(,14)
         L     1,0(,15)
         LHI   15,1
         L     0,R.LUCCOUNT
         C     0,L.LUCCOUNT
         JL    SC0200
         JH    SC0300
         L     0,L.LUCIP
         CL    0,R.LUCIP
         JL    SC0200
         JH    SC0300
         SPACE 2
         CNOP  0,8
L        USING IP,14
R        USING IP,1
XXXXCMP7 SAVE  14
         LM    14,15,0(1)
         L     14,0(,14)
         L     1,0(,15)
         LHI   15,1
         L     0,L.IPV4ADDR
         CLM   0,B'1111',R.IPV4ADDR
         JL    SC0200
         JH    SC0300
         J     SC0100
         SPACE 2
         CNOP  0,8
XXXXCMP8 SAVE  14
         LM    14,15,0(1)
         L     14,0(,14)
         L     1,0(,15)
         LHI   15,1
         CLC   4(8,14),4(1)
         JL    SC0200
         JH    SC0300
*        J     SC0100
SC0100   SR    15,15
         RETURN 14,RC=(15)
SC0200   LNR   15,15
SC0300   RETURN 14,RC=(15)
         DROP  L,R
         EJECT
         PUSH  USING
         CNOP  0,8
XXXXSCAN BASR  15,0                Store current address in reg 15
         USING *,10
         SAVE  (14,12),,PARMSCAN   Save registers
         LR    10,15
         LH    5,0(,2)             Load length of parm text
         LTR   5,5                 Any parm text?
         BNP   PS0800              No
         LA    5,1(5,2)            Compute address of last byte of    ->
                                    parm text
         LA    4,1                 Set reg 4 = 1
         LA    3,2(,2)             Compute address of first byte of   ->
                                    parm text
PS0100   LR    6,3                 Copy start of keyword t0 reg 6
PS0200   CLI   0(3),C','           End of keyword?
         BE    PS0300              Yes
         BXLE  3,4,PS0200          Try next byte
PS0300   LR    7,3                 Copy end of keyword to reg 7
         SR    7,6                 Compute keyword length
         BNP   PS0700              Br if null
         BCTR  7,0                 Reduce keyword length by 1
         LA    1,OPTAB             Load address of the keyword table
PS0400   CLI   0(1),X'FF'          End of keyword table?
         BE    PS0700              Yes
         CLM   7,B'0001',0(1)      Length match?
         BNE   PS0600              No
         EX    7,PS0500            Test if correct keyword
         BNE   PS0600              No
         NC    OPTION,1(1)         Turn off option bits
         OC    OPTION,2(1)         Turn on option bits
         B     PS0700
PS0500   CLC   3(*-*,1),0(6)       ** EX only **
PS0600   SR    15,15               Set reg 15
         IC    15,0(,1)            Load keyword length
         LA    1,4(15,1)           Compute address of the next keyword
         B     PS0400              Go check it
PS0700   CR    3,5                 End of parms
         BH    PS0800              Yes
         BXLE  3,4,PS0100          Bump parm text pointer
PS0800   RETURN (14,12)            Restore registers & return
         POP   USING
         EJECT
* Test if DD statements are present for DCBs in an OPEN parm list
         PUSH  USING
         DROP  12
         CNOP  0,8
XXXXTDD  BASR  15,0                Store current address in reg 15
         USING *,3                 Establish TESTDD addressability
         USING SAVE,13
         SAVE  (14,3),,TESTDD      Save registers
         LR    3,15                Prepare TESTDD base register
         LR    2,1                 Copy OPEN parm list address to reg 2
TDD0100  L     1,0(,2)             Load a DCB address
         N     1,=A(X'FFFFFF')     Isolate the 24-bit DCB address
         DEVTYPE DCBDDNAM-IHADCB(,1),DWORK  Test if DD name present
         LTR   15,15               Test DEVTYPE return code
         BNZ   TDD0200             Br if DD statement missing
         TM    0(2),X'80'          End of parm list?
         LA    2,4(,2)             Compute address of next DCB pointer
         BZ    TDD0100             Br if not end of OPEN parm list
TDD0200  RETURN (14,3),RC=(15)     Restore registers & return
         DROP  3,13
         POP   USING
         EJECT
         CNOP  0,8
XXXALLOC BASR  15,0                Store current address in reg 15
         USING *,10                Establish addressability
         SAVE  (14,12),,DYNALLOC   Save registers
         LR    10,15               Prepare base register
         LA    15,72(,13)          Compute address of next save area
         ST    13,4(,15)           Add new save area to the
         ST    15,8(,13)            save area chain
         LR    13,15               Prepare new save area pointer
         L     2,0(,1)             Load the request block address
         DYNALLOC ,                Allocate the data set
         LTR   3,15                Test the return code
         BZ    DYNA0300            Br if the allocate is OK
         ST    3,DYNRC             Save the return code for DAIRFAIL
         ST    2,DFS99RBP          Save the RB address for DAIRFAIL
         LINK  SF=(E,LINKDF),MF=(E,DFPARMS)  Run DAIRFAIL
         LTR   15,15               RC OK?
         BZ    *+L'*+2             Yes
         DC    H'0'                Oops
         LA    4,2                 Load number of message buffers
         L     5,DFBUFP            Load addr of the first buffer
DYNA0100 LH    1,0(,5)             Load message length
         AHI   1,-4                Subtract the length of the RDW
         BNP   DYNA0200            Br if message buffer is empty
         LA    0,4(,5)             Compute addr of text in the buffer
         LR    15,1                Copy the msg length to reg 15
         LA    14,FMTWORK+5        Load start of text in my msg buffer
         MVCL  14,0                Copy text to mt msg buffer
         LA    1,FMTWORK           Load addr of my msg buffer
         SR    14,1                Compute message length
         SLL   14,16               Convert msg length to an RDW
         ST    14,FMTWORK          Store the RDW
         MVI   FMTWORK+4,C' '      Insert the carriage control
         BAS   14,OUTEDIT          Write the DAIRFAIL message
DYNA0200 AHI   5,DFBUF2-DFBUF1     Compute addr of the next mressage
         BCT   4,DYNA0100          Go process the next message
DYNA0300 LR    15,3                Copy the DYNALLOC RC to reg 15
         L     13,4(,13)           Load addr of the higher save area
         RETURN (14,12),RC=(15)    Restore registers & return
         SPACE 1
LINKDF   LINK  SF=L,EP=IKJEFF18
         DROP  10
         EJECT
* Dump a data area
         CNOP  0,8
XXXXDUMP BASR  15,0                Store current address in reg 15
         USING *,10                Establish addressability
         SAVE  (14,12),,DUMPREC    Save registers
         LR    10,15               Prepare base register
         LA    15,72(,13)          Compute addr of the next save area
         ST    13,4(,15)           Add new save area to the
         ST    15,8(,13)            save area chain
         LR    13,15               Prepare new save area pointer
         LR    3,1                 Copy record address to reg 3
         LR    4,0                 Copy record length to reg 4
         LR    5,1                 Initialize current line address
         LA    0,L'MISC            Add miscellaneous charcters to thw
         LA    1,MISC               translate table
         SR    15,15
DUR0100  IC    15,0(,1)
         STC   15,TRTAB(15)
         AHI   1,1
         BCT   0,DUR0100
         MVI   DULINE+4,C'-'       Init carriage control for the      ->
                                    first line of the dump
DUR0200  MVI   DUCLEAR,C' '        Clear the hex character area
         MVC   DUCLEAR+1(L'DUCLEAR-1),DUCLEAR
         MVC   DUCHARS,C' '        Clear the character area
         MVC   DUCHARS+1(L'DUCHARS-1),DUCHARS
         LR    0,5                 Copy address of the line to reg 0
         SR    0,3                 Compute offset of the line
         STH   0,12(,13)           Store the offset in a work area
         UNPK  DUHOFF(5),12(3,13)  Convert the offset
         TR    DUHOFF,HEXTAB        to printable hexadecmal characters
         CVD   0,64(,13)           Convert the offset to decimal
         MVC   DUDOFF,=X'402020202120'  Convert the decimal offset
         ED    DUDOFF,72-3(13)           to decimal characters
         LR    0,4                 Copy remaining bytes to reg 0
         CHI   0,16                16?
         BNH   *+L'*+4             Br if 16 or less
         LHI   0,16                Load bytes in 1 line
         LA    1,DUTAB             Load addr of DUTAB
DUR0300  LH    15,2(,1)            Load offset of character data
         LA    15,DULINE(15)       Compute address of character data
         MVC   0(1,15),0(5)        Copy the character to output line
         LH    15,0(,1)            Load offset of the hex data area
         LA    15,DULINE(15)       Compute address of the hex data
         UNPK  0(3,15),0(2,5)      Convert 1 byte to 2
         TR    0(2,15),HEXTAB       hexadecimal characters
         MVI   2(15),C' '
         AHI   5,1                 Update the source data address
         AHI   1,4                 Compute addr of the next DUTAB entry
         BCT   0,DUR0300           Go do the next byte
         TR    DUCHARS,TRTAB       Make sure the characters can print
         LA    1,DULINE            Write the completed line
         BAS   14,OUTEDIT
         MVI   DULINE+4,C' '       Reset the carriage control character
         AHI   4,-16               Update remaining bytes
         BP    DUR0200             Br if more bytes to dump
         L     13,4(,13)           Load address of the higher save area
         RETURN (14,12)            Restore registers & return
         DROP  10
         EJECT
         CNOP  0,8
XXXXLOPT BASR  15,0                Store current address in reg 15
         USING *,5                 Establish addressability
         SAVE  (14,5),,LISTOPT     Save registers
         LR    5,15                Copy entry address to reg 5
         LA    14,72(,13)          Compute new save area address
         ST    13,4(,14)           Add new save area to the
         ST    15,8(,13)            save area chain
         LR    13,14
         LA    0,FMTWORK           Compute MINIFMT work area address
         LA    1,FMT15             Compute format address
         L     15,=V(MINIFMT)      Use MINIFMT to start the line
         CALL  (15)
         LR    2,1                 Copy the line address to reg 2
         LH    3,0(,1)             Load the length of the line
         AR    3,2                 Compute the start of the           ->
                                    option string
         LA    4,OPTABL            Compute start of the option table
LOPT0100 SR    15,15               Load length of the option
         IC    15,0(,4)
         CLI   0(4),X'FF'          End of the table?
         BE    LOPT0400            Yes
         MVC   12(1,13),OPTION     Copy the option bits to a work area
         NC    12(1,13),1(4)       Isolate the bits
         CLC   12(1,13),2(4)       Test if option
         BNE   LOPT0200            No
         MVI   0(3),C','           Insert a separator
         EX    15,LOPT0300         Copy option text
         LA    3,2(15,3)           Update the output line pointer
LOPT0200 LA    4,4(15,4)           Update the option table pointer
         B     LOPT0100            Conntinue option scan
LOPT0300 MVC   1(*-*,3),3(4)       ** EX ONLY **
LOPT0400 LH    15,0(,2)            Load length of the prefix
         AR    15,2                Compute addr of the option string
         MVI   0(15),C' '          Replace initial , w/ a blank
         SR    3,2                 Compute length of the line
         STH   3,0(,2)             Store the length in the RDW
         LR    1,2                 Write the completed line
         BAS   14,OUTEDIT
         L     13,4(,13)           Load address of the higher save area
         RETURN (14,5)             Restore registers & return
         DROP  5
         EJECT
         CNOP  0,8
CPAMT    EQU   4*1024              BYTES IN A SINGLE CELL POOL
XXXXGETM BASR  15,0                STORE CURRENT ADDRESS IN REG 15
         USING *,12                ESTABLISH ADDRESSABILITY
         USING CPOOL,10
         SAVE  (14,12),,GETMAIN    SAVE REGISTERS
         LR    12,15               COPY ENTRY POINT ADDRESS TO REG 12
         LR    2,0                 COPY AMOUNT OF STORAGE TO REG 2
         AHI   2,7                 ROUND REQUEST UP TO AN 8 BYTE
         N     2,ROUND8             MULTIPLE
GM0100   LA    10,CPLIST-(CPNEXT-CPOOL)  LOAD ADDR OF A DUMMY CPOOL
GM0200   ICM   10,B'1111',CPNEXT   LOAD ADDR OF THE NEXT CPOOL
         JZ    GM0300              BR IF END OF LIST
         C     2,CPLEFT            COMPARE REQUESTED AMOUNT WITH      ->
                                    FREE STORAGE IN THIS CPOOL
         JH    GM0200              BR IF NOT ENOUGH STORAGE IN THIS   ->
                                    CPOOL
         MVC   24(4,13),CPNEXTA    REPLACE CALLER'S REG 1 W/ CURRENT  ->
                                    FREE SPACE ADDRESS IN THIS CPOOL
         L     0,CPLEFT            LOAD FREE BYTES IN THIS CPOOL
         SR    0,2                 SUBTRACT AMOUNT OF STORAGE WE      ->
                                    JUST ALLOCATED
         ST    0,CPLEFT            UPDATE FREE SPACE AMOUNT
         A     2,CPNEXTA           ADD ADDRESS OF STORAGE WE JUST     ->
                                    ALLOCATED TO AMOUNT OF STORAGE    ->
                                     WE JUST ALLOCATED
         ST    2,CPNEXTA           UPDATE ADDRESS OF FREE STORAGE
         J     GM0800              AND EXIT
GM0300   LHI   0,CPAMT-(CPSTART-CPOOL)  SET REG 0 = FREE STORAGE IN A ->
                                         SINGLE CPOOL
GM0400   CR    0,2                 COMPARE W/ AMOUNT WE NEED
         JNL   GM0500              BR IF ENOUGH
         AHI   0,CPAMT             ADD CPAMT TO REG 0
         J     GM0400              CONTINUE
GM0500   AHI   0,CPSTART-CPOOL     SET REG 0 TO A K MULTIPLE
         LR    3,0                 COPY AMOUNT OF STORAGE TO REG 3
         TAM   ,                   TEST ADDRESSING MODE
         JNZ   GM0600              BR IF NOT AMODE 24
         GETMAIN RU,LV=(0)         ALLOCATE STORAGE
         J     GM0700
GM0600   GETMAIN RU,LV=(0),LOC=(31,ANY)  ALLOCATE STORAGE
GM0700   LR    10,1                COPY ADDRESS TO REG 11
*        XC    0(CPSTART-CPOOL,11),0(11)  CLEAR THE HEADER
         ST    3,CPSIZE            STORE THE SIZE
         LA    0,CPSTART
         ST    0,CPNEXTA
         AHI   3,-(CPSTART-CPOOL)  SUBTRACT HEADER SIZE FROM          ->
                                    ALLOCATED STORAGE
         ST    3,CPLEFT            STORE FREE SPACE SIZE
         MVC   CPNEXT,CPLIST       ADD THE NEW SUBPOOL TO THE
         ST    10,CPLIST            SUBPOOL CHAIN
         J     GM0100              AND RESTART ALLOCATION
GM0800   RETURN (14,12),T          RESTORE REGS & RETURN
         SPACE 5
         CNOP  0,8
XXXXFREE BASR  15,0                STORE CURRENT ADDRESS IN REG 15
         USING *,12                ESTABLISH ADDRESSABILITY
         SAVE  (14,12),,FREEALL    SAVE REGISTERS
         LR    12,15               COPY THE ENTRY POINT ADDR TO REG 12
FR0100   ICM   10,B'1111',CPLIST   LOAD ADDR OF THE NEXT CPOOL
         JZ    FR0200              EXIT IF DONE
         MVC   CPLIST,CPNEXT       REMOVE CURRENT CPOOL FROM THE CHAIN
         L     0,CPSIZE            LOAD SIZE
         FREEMAIN RU,LV=(0),A=(10) FREE THE CPOOL
         J     FR0100              GO FREE THE NEXT CPOOL
FR0200   RETURN (14,12),T          RESTORE REGS & RETURN
         SPACE 1
ROUND8   DC    F'-8'
         DROP  10                  Kill addressability
         EJECT
* SCAN118 data area
SCAN118D CSECT
OELINES  DC    0XL256'0'
* These statements depend on the EBCDIC collating sequence
         DC    (C' ')X'FF',AL1(1) Blank < + < - < 0              1 OF 5
         DC    (C'+'-(*-OELINES))X'FF',AL1(0)                    2 OF 5
         DC    (C'-'-(*-OELINES))X'FF',AL1(3)                    3 OF 5
         DC    (C'0'-(*-OELINES))X'FF',AL1(2)                    4 OF 5
         DC    (256-(*-OELINES))X'FF'                            5 OF 5
*                  0 - - - - + - - - - A - - - - F
* TPTAB1   DC    0XL256'0'
*        DC    10X'00000000000000000000040404040404'
*        DC     6X'04040404040404040404040404040404'
* TPTAB2   DC    0XL256'0'
*        DC    10X'00000000000000000000000400040000'
*        DC     6X'04040404040404040404040404040404'
SAVEAREA DC    (7*9)D'0'           7 72 byte OS/360 save areas
FMTWORK  DC    XL200'0'            MINIFMT work area
FIRSTTME DC    F'0'
FIRSTDTE DC    PL4'0'
LOWREC   DC    0XL8'0',X'7FFFFFFF',PL4'9999999'
HIGHREC  DC    0XL8'0',F'0',PL4'0'
         PUSH  PRINT
         PRINT NOGEN
         IKJEFFDF DFDSECT=NO,DFDSEC2=YES
SCAN118D CSECT
         ORG   DFPARMS
         DC    A(*-*)              DFS99RBP
         DC    A(DYNRC)            DFRCP
         DC    A(A0)               DFJEFF02
         DC    A(DYNID)            DFIDP
         DC    A(0)                DFCPPLP
         DC    A(DYNBUFS)          DFBUFB
A0       DC    A(0)
DYNRC    DC    F'0'
DYNID    DC    0AL2(0),AL1(DFBUFSW,DFSVC99)
         POP   PRINT
IPLIST   DC    A(*-*)
CPLIST   DC    A(*-*)
A        DC    A(X'80000000'+ARB)
ARB      DC    AL1(S99RBEND-S99RB,S99VRBAL,S99NOMNT,0)
         DC    2AL2(0),A(ATXTPP,0,0)
ATXTPP   DC    A(ATXT01,ATXT02,ATXT03,X'80000000'+ATXT04)
ATXT01   DC    AL2(DALDSNAM,1,L'ADSN)
ADSN     DC    CL44' '
ATXT02   DC    AL2(DALDDNAM,1,L'ADDN)
ADDN     DC    CL8'SMF'
ATXT03   DC    AL2(DALRTORG,1,L'ADSORG)
ADSORG   DC    AL2(*-*)
ATXT04   DC    AL2(DALSTATS,1,1),X'08'
         DC    0D'0'
XLOW     DC    XL8'0'
XHIGH    DC    XL8'0'
LINECT   DC    H'255',0F'0'        Initial page position
RCOUNT   DC    F'0'
SECOUNT  DC    F'0'
LUCOUNT  DC    F'0'
ERRCNT   DC    F'0'
LULIST   DC    A(*-*)              -> First LU
ACTLIST  DC    A(*-*)              -> First LUACT
SELIST   DC    A(*-*)              -> First SESSION
LUCLIST  DC    A(*-*,LUCLIST-(LUCNEXT-LUC)) -> First & last LUACT
SORTPARM CALL  ,(LULIST,LUOFF,SORTCMP1),MF=L  QSORTL parameter list
LUOFF    DC    A(LUNEXT-LU)        Offset of next pointer
EPARM    CALL  ,(*-*,*-*,DUR),MF=L SMFETIME parameter list
DUR      DC    F'0'
         PUSH  PRINT
         PRINT NOGEN
OPARM01  OPEN  (PRINT,OUTPUT),MF=L
CPARM01  CLOSE (PRINT),MF=L
OPARM02  OPEN  (SMF,INPUT),MF=L
CPARM02  CLOSE SMF,MF=L
OPARM03  OPEN  (SMFACB,INPUT),MF=L
CPARM03  CLOSE SMFACB,MF=L
PRINT    DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=VBA,LRECL=125
SMF      DCB   DSORG=PS,MACRF=GL,DDNAME=SMF,EODAD=SMFEOF,BFTEK=A
SMFDCB   EQU   SMF,*-SMF
SMFACB   ACB   DDNAME=SMF,BUFND=10,MACRF=(ADR,SEQ,IN),                ->
               AM=VSAM,EXLST=XLIST1
XLIST1   EXLST EODAD=(SMFEOF,A)
SMFRPL   RPL   ACB=SMFACB,AREALEN=L'IOBUF,AREA=IOBUF,                 ->
               OPTCD=(ADR,SEQ,MVE,SYN,NUP),AM=VSAM
         POP   PRINT
         DC    0D'0'
         LTORG ,
LEFT     EQU   ((120-L'HDR)/2)+1
RIGHT    EQU   111-LEFT-L'HDR
PAGEHDR  DC    AL2(PAGEHDRL,0),CL(LEFT)'1(SCAN118 V1L5 &SYSDATE &SYSTIM>
               E)'
HDR      DC    C'T S O   U S E R   I P   A D D R E S S E S'
         DC    CL(RIGHT)' '
         DC    C'PAGE'
PAGE#    DC    C' NNNNN'
PAGEHDRL EQU   *-PAGEHDR
PAGENUM  DC    P'00000'
         SPACE 1
* MINIFMT formats
         SPACE 1
FMT01    DC    AL.2(2),AL.6(4),AL1(1,1),X'FF' Format system date & time
         SPACE 1
         USING LUACT,4
         USING LU,3
FMT02    DC    AL.2(3),AL.6(0),AL1(L'CC,L'CC),SL2(CC)
         DC    AL.2(3),AL.6(5),AL1(10,0),SL2(XLOW)
         DC    AL1(1),C'/'
         DC    AL.2(3),AL.6(5),AL1(13,3),SL2(XLOW)
         DC    AL1(2),C'->'
         DC    AL.2(3),AL.6(5),AL1(10,0),SL2(XHIGH)
         DC    AL1(1),C'/'
         DC    AL.2(3),AL.6(5),AL1(13,3),SL2(XHIGH)
         DC    AL1(1),C' '
         DC    AL.2(3),AL.6(0),AL1(L'LUNAME,L'LUNAME),SL2(LUNAME)
         DC    AL.2(3),AL.6(0),AL1(L'DTIME,L'DTIME+1),SL2(DTIME)
         DC    AL.2(3),AL.6(0),AL1(L'IPADDR,0),SL2(IPADDR),X'FF'
         DROP  3,4
         SPACE 1
FMT03    DC    AL1(L'FMT03A)
FMT03A   DC    C' NO VALID SMF DATA!',X'FF'
         SPACE 1
FMT04    DC    AL1(L'FMT04A)
FMT04A   DC    C' SMF DATA FROM '
         DC    AL.2(3),AL.6(5),AL1(1,1),SL2(LOWREC)
         DC    AL1(L'FMT04B)
FMT04B   DC    C' TO '
         DC    AL.2(3),AL.6(5),AL1(1,1),SL2(HIGHREC)
         DC    AL1(L'FMT04C)
FMT04C   DC    C', '
         DC    AL.2(3),AL.6(10),AL1(L'SECOUNT,0),SL2(SECOUNT)
         DC    AL1(L'FMT04D)
FMT04D   DC    C' TSO SESSIONS, '
         DC    AL.2(3),AL.6(10),AL1(L'LUCOUNT,0),SL2(LUCOUNT)
         DC    AL1(L'FMT04E)
FMT04E   DC    C' TCPIP SESSIONS',X'FF'
         SPACE 1
         USING SESSION,4
FMT06    DC    AL.2(3),AL.6(0),AL1(L'CC,L'CC),SL2(CC)
         DC    AL.2(3),AL.6(0),AL1(L'SEUSER,L'SEUSER),SL2(SEUSER)
         DC    AL.2(3),AL.6(5),AL1(10,0),SL2(SEONDT)
         DC    AL1(1),C'/'
         DC    AL.2(3),AL.6(5),AL1(13,3),SL2(SEONDT)
         DC    AL1(2),C'->'
         DC    AL.2(3),AL.6(5),AL1(10,0),SL2(SEOFFDT)
         DC    AL1(1),C'/'
         DC    AL.2(3),AL.6(5),AL1(13,3),SL2(SEOFFDT)
         DC    AL.2(3),AL.6(0),AL1(L'DTIME,L'DTIME+1),SL2(DTIME)
         DC    AL.2(3),AL.6(0),AL1(L'SELU,L'SELU+1),SL2(SELU)
         DC    AL.2(3),AL.6(0),AL1(L'IPADDR,0),SL2(IPADDR)
         DC    X'FF'
         DROP  4
         SPACE 1
FMT07    DC    AL1(L'FMT07A)
FMT07A   DC    C'1TCPIP SESSIONS SORTED BY SESSION START TIME',X'FF'
         SPACE 1
FMT08    DC    AL1(L'FMT08A)
FMT08A   DC    C'1IP ADDRESSES BY USE COUNT',X'FF'
         SPACE 1
         USING LUC,2
FMT09    DC    AL1(1),C' '
         DC    AL.2(3),AL.6(0),AL1(L'IPADDR,L'IPADDR),SL2(IPADDR)
         DC    AL.2(3),AL.6(1),AL1(L'LUCCOUNT,5),SL2(LUCCOUNT),X'FF'
         DROP  2
         SPACE 1
FMT10    DC    AL1(L'FMT10A)
FMT10A   DC    C' SMF DATA SET WITH RECFM = '
         DC    AL.2(3),AL.6(8),AL1(L'DCBRECFM,0),SL2((DCBRECFM-IHADCB)+>
               SMFDCB)
         DC    AL1(L'FMT10B)
FMT10B   DC    C' DOES NOT CONTAIN SMF DATA',X'FF'
         SPACE 1
FMT11    DC    AL1(L'FMT11A)
FMT11A   DC    C' SMF DATA SET NOT SPECIFIED IN JCL, BUT UNABLE TO FIND>
                THE ACTIVE MAN DATA SET',X'FF'
         SPACE 1
FMT12    DC    AL1(L'FMT12A)
FMT12A   DC    C' USING ACTIVE MAN DATA SET '
         DC    AL.2(3),AL.6(0),AL1(L'ADSN,0),SL2(ADSN)
         DC    X'FF'
         SPACE 1
FMT13    DC    AL1(L'FMT13A)
FMT13A   DC    C'0THE FOLLOWING DATA DOES NOT APPEAR TO BE SMF DATA'
         DC    X'FF'
         SPACE 1
FMT14    DC    AL1(L'FMT14A)
FMT14A   DC    C'1THE FOLLOWING IP ADDRESSES ARE USED BY TWO OR MORE US>
               ERS'
         DC    X'FF'
         SPACE 1
FMT15    DC    AL1(L'FMT15A)
FMT15A   DC    C'-OPTIONS -',X'FF'
         SPACE 1
SUBHDR   DC    2AL2(0),CL121' '
         SPACE 1
CC       DC    C' '
IPADDR   DC    0C'NNN.NNN.NNN.NNN',CL(L'IPADDR)' ',C' '
DMASK    DC    0C' HHHHH:MM',C' ',3X'20',X'2120',C':',X'2020'
DTIME    DC    CL(L'DMASK)' '
         SPACE 1
         DC    0D'0'
TRTAB    DC    0CL256' ',(C' ')C'.'
         DC    C' ',(C'A'-X'40'-(*-TRTAB))C'.'
         DC    9AL1(*-TRTAB),(C'J'-X'40'-(*-TRTAB))C'.'
         DC    9AL1(*-TRTAB),(C'S'-X'40'-(*-TRTAB))C'.'
         DC    8AL1(*-TRTAB),(C'A'-(*-TRTAB))C'.'
         DC    9AL1(*-TRTAB),(C'J'-(*-TRTAB))C'.'
         DC    9AL1(*-TRTAB),(C'S'-(*-TRTAB))C'.'
         DC    8AL1(*-TRTAB),(C'0'-(*-TRTAB))C'.'
         DC    10AL1(*-TRTAB),(256-(*-TRTAB))C'.'
HEXTAB   EQU   *-C'0'
         DC    C'0123456789ABCDEF'
DUTAB    DC    AL2(DUWORD1-DULINE+00,DUCHARS-DULINE+00)
         DC    AL2(DUWORD1-DULINE+02,DUCHARS-DULINE+01)
         DC    AL2(DUWORD1-DULINE+04,DUCHARS-DULINE+02)
         DC    AL2(DUWORD1-DULINE+06,DUCHARS-DULINE+03)
         DC    AL2(DUWORD2-DULINE+00,DUCHARS-DULINE+04)
         DC    AL2(DUWORD2-DULINE+02,DUCHARS-DULINE+05)
         DC    AL2(DUWORD2-DULINE+04,DUCHARS-DULINE+06)
         DC    AL2(DUWORD2-DULINE+06,DUCHARS-DULINE+07)
         DC    AL2(DUWORD3-DULINE+00,DUCHARS-DULINE+08)
         DC    AL2(DUWORD3-DULINE+02,DUCHARS-DULINE+09)
         DC    AL2(DUWORD3-DULINE+04,DUCHARS-DULINE+10)
         DC    AL2(DUWORD3-DULINE+06,DUCHARS-DULINE+11)
         DC    AL2(DUWORD4-DULINE+00,DUCHARS-DULINE+12)
         DC    AL2(DUWORD4-DULINE+02,DUCHARS-DULINE+13)
         DC    AL2(DUWORD4-DULINE+04,DUCHARS-DULINE+14)
         DC    AL2(DUWORD4-DULINE+06,DUCHARS-DULINE+15)
         SPACE 1
DULINE   DC    AL2(DULINEL,0),C' '
DUHOFF   DC    C'HHHH'
DUDOFF   DC    C' NNNNN',C' '
DUWORD1  DC    C'HHHHHHHH',C' '
DUWORD2  DC    C'HHHHHHHH',CL2' '
DUWORD3  DC    C'HHHHHHHH',C' '
DUWORD4  DC    C'HHHHHHHH'
DUCLEAR  EQU   DUWORD1,*-DUWORD1
         DC    C'  *'
DUCHARS  DC    CL16' ',C'*'
DULINEL  EQU   *-DULINE
         SPACE 1
* The last character in MISC is X'9E', the commonly accepted
* EBCDIC Euro symbol
MISC     DC    C'~!@#$%^&&*()_+=-{}|\]["''?><,.?Æ'
         SPACE 1
RC       DC    AL1(0)
OPTION   DC    AL1(SORTTIME+SESSOPT)
SORTTIME EQU   B'10000000'
SORTUSER EQU   B'01000000'
SORTIP   EQU   B'00100000'
SORTOPT  EQU   SORTTIME+SORTUSER+SORTIP
DUMPRECS EQU   B'00010000'
SESSOPT  EQU   B'00001000'
VSAM     EQU   B'00000001'
OPTAB    DC    AL1(7,255-SORTOPT,SORTTIME),C'SORTTIME'
         DC    AL1(7,255-SORTOPT,SORTUSER),C'SORTUSER'
         DC    AL1(5,255-SORTOPT,SORTIP),C'SORTIP'
*                                    ----+---
         DC    AL1(7,255,DUMPRECS),C'DUMPRECS'
*                                      ----+----1
         DC    AL1(9,255-DUMPRECS,0),C'NODUMPRECS'
*                                   ----+--
         DC    AL1(6,255,SESSOPT),C'SESSION'
*                                     ----+----
         DC    AL1(8,255-SESSOPT,0),C'NOSESSION'
         DC    X'FF'
         SPACE 1
OPTABL   DC    AL1(7,SORTOPT,SORTTIME),C'SORTTIME'
         DC    AL1(7,SORTOPT,SORTUSER),C'SORTUSER'
         DC    AL1(5,SORTOPT,SORTIP),C'SORTIP'
         DC    AL1(7,DUMPRECS,DUMPRECS),C'DUMPRECS'
*        DC    AL1(9,DUMPRECS,0),C'NODUMPRECS'
         DC    AL1(6,SESSOPT,SESSOPT),C'SESSION'
         DC    AL1(8,SESSOPT,0),C'NOSESSION'
         DC    X'FF'
         SPACE 1
         DC    0D'0'
HASHTAB  DC    31A(*-*)
HASHNUM  EQU   (*-HASHTAB)/L'HASHTAB
         DC    0D'0'
SESSTAB  DC    31A(*-*)
SESSNUM  EQU   (*-SESSTAB)/L'SESSTAB
         SPACE 2
         DC    0D'0'
IPTAB    DC    31A(*-*)
IPNUM    EQU   (*-IPTAB)/L'IPTAB
         DC    0D'0'
DYNBUFS  DC    (2*(DFBUF2-DFBUF1))X'00'
         ORG   DYNBUFS
IOBUF    DS    XL(32767),0D
         END   SCAN118
